include "../../jl5/parse/jl5_ppg.cup"

package polyglot.ext.esj.parse;

import java.util.*;

import polyglot.ext.esj.types.ESJTypeSystem;
import polyglot.ext.esj.ast.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl5.parse.*;

parser Grm extends polyglot.ext.jl5.parse.Grm {:
    public final ESJTypeSystem ts;
    public final ESJNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (ESJTypeSystem) t;
        nf = (ESJNodeFactory) n;
    }
:};

terminal Token PREDICATE;
terminal Token SOME;
terminal Token ALL;

non terminal MethodDecl pred_method_declaration, pred_method_header;
non terminal Block pred_method_body, pred_block;
non terminal List pred_block_statements, pred_block_statement;
non terminal Stmt pred_statement;
non terminal Expr pred_statement_expression, pred_expression;

start with goal;

// Here begins the ESJ grammar extensions and modifications

extend class_member_declaration ::=
        pred_method_declaration:a {:
           List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
	   :}
	   ;

pred_method_declaration ::=
        pred_method_header:a pred_method_body:b 
	   {: RESULT = (MethodDecl) a.body(b); :}
	   ;

pred_method_header ::=
        PREDICATE:a method_header:b
       	   {: RESULT = b; :}
	   ;

pred_method_body ::=
        pred_block:a 
	   {:  RESULT = a;  :}
	   ;

pred_block ::=
    LBRACE:n pred_block_statements:a RBRACE:d 
           {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
	   ;

pred_block_statements ::= 
    pred_block_statement:a
           {: List l = new TypedList(new LinkedList(), Stmt.class, false);

	       FlagAnnotations fl = new FlagAnnotations(); 
               fl.classicFlags(Flags.NONE);
               fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
               List vds = parser.variableDeclarators(parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Int()),
						     new VarDeclarator(parser.pos(a),
                            			                       "quantList"), 
						     fl); 


 	      Expr assign = parser.nf.Assign(parser.pos(a, a), 
	                                    new JL5Name(parser, parser.pos(a), "quantList").toExpr(), 
	      				    Assign.ASSIGN, 		
	      				    parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                                             42));
	      Stmt assignStmt = parser.nf.Eval(parser.pos(assign, assign), assign);
              List b = new TypedList(new LinkedList(), Stmt.class, false);
              b.add(assignStmt);
	      l.addAll(vds);
	      l.addAll(b); 
              l.addAll(a);
              RESULT = l; 
           :}
	   ;

pred_block_statement ::=
    pred_statement:a 
           {: List l = new TypedList(new LinkedList(), Stmt.class, false);
              l.add(a);
              RESULT = l; 
           :}
	   ;

pred_statement ::=
    pred_statement_expression:a SEMICOLON:d 
           {: RESULT = parser.nf.JL5Return(parser.pos(a, d), a); :}
	   ;

pred_statement_expression ::=
    pred_expression:a 
           {:  RESULT = a;  :}
    	   ;

pred_expression ::=
        ALL:a name:b COLON:c primary_no_new_array:d OR:e conditional_expression:f
       	   {: RESULT = f; :}
	   ;       
