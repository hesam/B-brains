package polyglot.ext.esj.parse;

import java.util.*;
import java_cup.runtime.*;
import polyglot.ast.*;
import polyglot.lex.*;
import polyglot.util.*;
import polyglot.parse.*;
import polyglot.types.*;
import polyglot.*;
import polyglot.ast.Assert;
import polyglot.ext.jl5.types.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl.ast.*;
import polyglot.ext.jl.parse.Name;
import java.util.*;
import polyglot.ext.esj.types.ESJTypeSystem;
import polyglot.ext.esj.ast.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl5.parse.*;

parser Grm extends polyglot.ext.jl5.parse.Grm {:

    public final ESJTypeSystem ts;
    public final ESJNodeFactory nf;

    // FIXME 
    String currClassName;
    List classFieldNs = new TypedList(new LinkedList(), String.class, false);
    List enums = new TypedList(new LinkedList(), String.class, false);
    boolean noClosureDefYet = true;
    //List currClassLogPredMtdDecls = new TypedList(new LinkedList(), MethodDecl.class, false);

    public void resetGlobals() {
	noClosureDefYet = true;
	//currClassLogPredMtdDecls = new TypedList(new LinkedList(), MethodDecl.class, false);
    }

    public void currClassName(String n) { this.currClassName = n; }
    public void noClosureDefYet(boolean b) { this.noClosureDefYet = b; }

    
    FlagAnnotations emptyFlags = makeFlagAnnotations();
    List emptyArgs = new TypedList(new LinkedList(), Expr.class, false);
    List emptyFormals = new TypedList(new LinkedList(), Formal.class, false); 

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (ESJTypeSystem) t;
        nf = (ESJNodeFactory) n;
    }

    public List addESJClassDecl (ClassDecl a) throws Exception {
	// also define LogVar for the class
	List l = new TypedList(new LinkedList(), TopLevelDecl.class, false); 
	l.add(a);
	/*
	if (a instanceof ESJEnsuredClassDecl && !currClassName.equals("MyList")) { //FIXME
	    String logVarCN = a.name() + "LogVar";
	    TypedList cb = new TypedList(new LinkedList(), ClassMember.class, false);
	    List args = new TypedList(new LinkedList(), Expr.class, false);
	    args.add(nf.Local(null,"string"));
	    args.add(nf.Local(null,"logType"));
	    List l2 = new TypedList(new LinkedList(), Stmt.class, false);
	    l2.add(nf.SuperCall(null, args));
	    List<Flags> fs = new ArrayList<Flags>();
	    fs.add(Flags.PUBLIC);
	    List frms = new TypedList(new LinkedList(), Formal.class, false);
	    frms.add(nf.JL5Formal(null, emptyFlags, nf.CanonicalTypeNode(null, ts.String()), "string"));
	    frms.add(nf.JL5Formal(null, emptyFlags, nf.CanonicalTypeNode(null, ts.Class()), "logType"));
	    cb.add(nf.JL5ConstructorDecl(null, makeFlagAnnotations(fs), logVarCN, frms, new TypedList(new LinkedList(), TypeNode.class, false), nf.Block(null, l2), new TypedList(new LinkedList(), TypeNode.class, false)));
	    for (JL5MethodDecl m : (List<JL5MethodDecl>) currClassLogPredMtdDecls)
		cb.add(nf.JL5MethodDecl(null, emptyFlags, nf.CanonicalTypeNode(null,ts.Boolean()), m.name(), emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), nf.Block(null,nf.JL5Return(null,nf.BooleanLit(null,false))), new TypedList(new LinkedList(), TypeNode.class, false)));
	    ESJLogVarClassDecl logVarClassDecl = nf.ESJLogVarClassDecl(null, emptyFlags, logVarCN, nf.CanonicalTypeNode(null, ts.typeForName("polyglot.ext.esj.tologic.LogVar")), new TypedList(new LinkedList(), TypeNode.class, false),  nf.JL5ClassBody(null, cb), new TypedList(new LinkedList(), TypeNode.class, false));
	    logVarClassDecl.logPredMtdDecls(currClassLogPredMtdDecls);
	    l.add(logVarClassDecl); 

	    }*/
	return l;
    }

    // define separate methods for each universal/existential expressions
    // also define relational-logic counterparts, to be used by external solvers...
    public List<JL5MethodDecl> defineESJExtraMethods(ESJMethodDecl methodDecl) throws Exception {
              List extraMtds = new TypedList(new LinkedList(), ClassMember.class, false);

	      // find the pred_expression subexprs within the body and mark them	    
	      List predExprs = getPredExprsWithinBody(methodDecl);
	      FlagAnnotations fl = emptyFlags;
	      List mStmts = new TypedList(new LinkedList(), Stmt.class, false);
	      List logmStmts = new TypedList(new LinkedList(), Stmt.class, false);
              mStmts.add(nf.JL5Return(null, nf.BooleanLit(null,true)));
              logmStmts.add(nf.JL5Return(null, nf.NullLit(null)));

	      for (ESJQuantifyExpr a : (List<ESJQuantifyExpr>)predExprs) {
	          a.parentMethod(methodDecl);
    	      	  String quantMtdId = a.id();
		  FormulaBinary.Operator quantKind = a.quantKind();
		  String quantVarN = a.quantVarN();
		  Expr quantList = a.quantListExpr();
                  ESJQuantifyClauseExpr quantExpr = a.quantClauseExpr();
		  List quantVarD = a.quantVarD();
		  List quantVarD2 = a.quantVarD2();
		  boolean isComprehension = a.isComprehension();
		  List frms = new TypedList(new LinkedList(), Formal.class, false);
		  TypeNode rTp = nf.CanonicalTypeNode(null,ts.Boolean());
		  frms.addAll(methodDecl.formals());
		  for(LocalDecl d : (List<LocalDecl>)quantVarD2)
		      frms.add(nf.JL5Formal(null, emptyFlags, d.type(), d.name()));

		  boolean quantKindIsaCount = quantKind == FormulaBinary.ONE ||
		  	    quantKind == FormulaBinary.LONE;
	      	  List stmts = new TypedList(new LinkedList(), Stmt.class, false);
		  if (quantKindIsaCount) {
		      stmts.add(nf.JL5LocalDecl(null, emptyFlags, nf.CanonicalTypeNode(null, ts.Int()), "quantCount", nf.IntLit(null, IntLit.INT, 0)));		  
		  } 
		  stmts.addAll(mStmts);
	      	  ESJPredMethodDecl extraMtd = 
		      nf.ESJPredMethodDecl(null, fl,
					   rTp, 
					   methodDecl.name() + "_" + quantMtdId, 
					   frms, 
					   new TypedList(new LinkedList(), TypeNode.class, false), 
					   nf.Block(null, stmts), methodDecl.throwTypes(),
					   quantMtdId, quantKind, quantVarN, 
					   quantVarD, quantList, quantExpr, isComprehension);
                  extraMtds.add(extraMtd);

             }

	     FormulaBinary.Operator quantKind = FormulaBinary.ALL;
	     String quantVarN = null;
	     List quantVarD = new TypedList(new LinkedList(), LocalDecl.class, false);
	     List quantVarD2 = new TypedList(new LinkedList(), LocalDecl.class, false);
	     boolean isComprehension = false;
	     if (predExprs.size() > 0) {
	     	ESJQuantifyExpr a = (ESJQuantifyExpr) predExprs.get(0);
	 	quantKind = a.quantKind();
	 	quantVarN = a.quantVarN();
		quantVarD = a.quantVarD();
		quantVarD2 = a.quantVarD2();
		isComprehension = a.isComprehension();
	     }
	     ESJLogPredMethodDecl extraLogMtd = 
		 nf.ESJLogPredMethodDecl(null, fl,
					 methodDecl.returnType(),
					 methodDecl.name() + "_log", 
					 methodDecl.formals(), 
					 new TypedList(new LinkedList(), TypeNode.class, false), 
					 null, 
					 methodDecl.throwTypes(), quantVarD, quantVarD2, methodDecl.isPredicate(), false, false); 
	     Block logPredBlock = this.makeESJLogPredBlock(((Return) methodDecl.body().statements().get(0)).expr(), quantVarD, quantVarN, extraLogMtd, isComprehension);
	     extraLogMtd = (ESJLogPredMethodDecl) extraLogMtd.body(logPredBlock);
             extraMtds.add(extraLogMtd);
	     //currClassLogPredMtdDecls.add(extraLogMtd);

	     return extraMtds;
    }


    public List getPredExprsWithinBody(JL5MethodDecl methodDecl) {
	      List predSubExprs = new TypedList(new LinkedList(), ESJQuantifyExpr.class, false);
	      Expr fullExpr = ((Return)(methodDecl.body().statements().get(0))).expr();
	      getPredExprsWithinBodyHelper(fullExpr,predSubExprs);	      
	      return predSubExprs;
     }

     public void getPredExprsWithinBodyHelper(Expr n,List predSubExprs) {
     	    if (n instanceof Binary) {
	          getPredExprsWithinBodyHelper(((Binary)n).left(),predSubExprs);
	          getPredExprsWithinBodyHelper(((Binary)n).right(),predSubExprs);
	    } else if (n instanceof Conditional) {
		 getPredExprsWithinBodyHelper(((Conditional)n).consequent(),predSubExprs);
		 getPredExprsWithinBodyHelper(((Conditional)n).alternative(),predSubExprs);
	    } else if (n instanceof ESJQuantifyExpr) {
	          predSubExprs.add(n);
		  getPredExprsWithinBodyHelper(((ESJQuantifyExpr)n).quantClauseExpr().expr(),predSubExprs);
	    }
     }

     public ESJEnsuredMethodDecl makeESJEnsuredMethodDecl(Position pos, FlagAnnotations flags,
				  TypeNode returnType, String name,
				  List formals, List throwTypes, Block body, 
				  List paramTypes, Expr ensuresExpr, List modifiableFields,
				  Expr modifiableObjects) throws Exception {
	    FlagAnnotations fl = emptyFlags;
	    TypeNode cftn = this.nf.CanonicalTypeNode(null, this.ts.Throwable());
	    JL5Formal catchFormal = this.nf.JL5Formal(null, fl, cftn, "rte");
       	    return this.nf.ESJEnsuredMethodDecl(pos, flags, returnType, name, formals, throwTypes, body, paramTypes, ensuresExpr, catchFormal, modifiableFields, modifiableObjects); 
     }    

     public ESJLogPredMethodDecl makeFallbackMtd(ESJEnsuredMethodDecl methodDecl, List modifiableFields, Expr modifiableObjects) throws SemanticException {
	    FlagAnnotations fl = emptyFlags; 
	    //System.out.println(methodDecl.body());
	    List args = new TypedList(new LinkedList(), Expr.class, false);
	    List args2 = new TypedList(new LinkedList(), Expr.class, false);
	    List args3 = new TypedList(new LinkedList(), Expr.class, false);
	    args.add(nf.StringLit(null,"fallback initiated..."));
	    Expr probFormula = methodDecl.ensuresExpr();
	    LocalDecl d1 = nf.JL5LocalDecl(null, fl, nf.CanonicalTypeNode(null, ts.Boolean()), "problem", probFormula);
	    args2.add(nf.Local(null,"problem"));
	    args3.add(nf.This(null));
	    args3.add(nf.Local(null,"problem"));
	    args3.add(modifiableFields == null ? nf.NullLit(null) : nf.Local(null,"modifiableFields"));
	    args3.add(modifiableObjects == null ? nf.NullLit(null) : modifiableObjects);
	    List l = new TypedList(new LinkedList(), Stmt.class, false);
	    LocalDecl d2 = nf.LocalDecl(null, fl.classicFlags(), nf.CanonicalTypeNode(null, ts.Boolean()), "isSatisfiable", nf.Call(null, nf.CanonicalTypeNode(null, ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "solve", args3));
	    l.add(nf.Eval(null,nf.Call(null, nf.Field(null, nf.CanonicalTypeNode(null, ts.typeForName("java.lang.System")),"out"), "println", args)));

	    List gt = new TypedList(new LinkedList(), TypeNode.class, false);
	    gt.add(nf.CanonicalTypeNode(null, ts.String()));
	    gt.add(nf.CanonicalTypeNode(null, ts.String()));
	    AmbTypeNode tn = nf.AmbTypeNode(null, "java.util.HashMap");
	    AmbTypeNode atn = nf.JL5AmbTypeNode(null, ((AmbTypeNode)tn).qual(), ((AmbTypeNode)tn).name(), gt);
	    
	    if (modifiableFields != null) {
		l.add(nf.LocalDecl(null, fl.classicFlags(), atn, "modifiableFields", nf.JL5New(null, atn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
		for(Name s : (List<Name>) modifiableFields) {
		    List as = new TypedList(new LinkedList(), Expr.class, false);
		    as.add(nf.StringLit(null, s.toString()));
		    as.add(nf.NullLit(null));
		    l.add(nf.Eval(null, nf.Call(null, nf.Local(null,"modifiableFields"), "put", as)));
		}
	    }
	    l.add(d1);
	    l.add(d2);
	    //l.add(nf.Eval(null,nf.Call(null, nf.Field(null, nf.CanonicalTypeNode(null, ts.typeForName("java.lang.System")),"out"), "println", args2)));
	    l.add(nf.JL5Assert(null, nf.Local(null,"isSatisfiable"), nf.StringLit(null, "Formula UNSAT! Recovery failed...")));
	    l.add(nf.Return(null, nf.Local(null,"isSatisfiable")));
	    List frms = new TypedList(new LinkedList(), Formal.class, false); 
	    frms.addAll(methodDecl.formals());
     	    return nf.ESJLogPredMethodDecl(null, fl,
	                                          nf.CanonicalTypeNode(null,ts.Boolean()),
						  methodDecl.name() + "_fallback", 
						  frms, 
						  new TypedList(new LinkedList(), TypeNode.class, false), 						  
						  nf.Block(null,l),
					   methodDecl.throwTypes(), new TypedList(new LinkedList(), LocalDecl.class, false), new TypedList(new LinkedList(), LocalDecl.class, false), false,true, false); 

     }

     public ESJQuantifyExpr makeESJQuantifyExpr(Position pos, boolean isComprehension, FormulaBinary.Operator quantKind, TypeNode tn, String quantVarN, Expr quantListExpr, Expr quantClauseExpr) throws Exception {
	    
	    // FIXME
	    if (tn.toString().equals("polyglot.ext.esj.primitives.ESJInteger{amb}")) {
	       	 tn = nf.CanonicalTypeNode(null, ts.Int());
	    }

	    FlagAnnotations fl = emptyFlags; 
	    List quantVarD = new TypedList(new LinkedList(), LocalDecl.class, false);
	    List quantVarD2 = new TypedList(new LinkedList(), LocalDecl.class, false);
	    JL5LocalDecl ld = nf.JL5LocalDecl(null, fl, tn, quantVarN, null);
	    quantVarD.add(ld);
	    propogateQuantVarDs(quantClauseExpr, quantVarD); //FIXME
	    return this.nf.ESJQuantifyExpr(pos,quantKind,quantVarN, quantVarD, quantVarD2, quantListExpr,quantClauseExpr,isComprehension);
}

	    //FIXME
     public Block makeESJLogPredBlock(Expr expr, List quantVarD, String quantVarN, ESJLogPredMethodDecl m, boolean isComprehension) throws SemanticException {
	    FlagAnnotations fl = emptyFlags; 
	    Expr newExpr = makeESJLogPredBlockHelper(expr, new TypedList(new LinkedList(), LocalDecl.class, false), m, isComprehension);
	    List l = new TypedList(new LinkedList(), Stmt.class, false);
	    l.add(nf.Return(null, newExpr));
	    return nf.Block(null, l); 
     }    

     public void BuildRelationizeOldAndCloneBody(List y, List relationizeOldMtdBody, List relationizeMtdSubBody, List cloneBody) throws SemanticException {
	 for (Node n : (List<Node>) y) {
	     if (n instanceof ESJFieldDecl) {
		 ESJFieldDecl fi = (ESJFieldDecl) n;
		 if (!fi.isOld()) {
		     boolean isEnumFd = fi.type() instanceof JL5AmbTypeNode && enums.contains(((AmbTypeNode) fi.type()).name());
		     classFieldNs.add(fi.name());
		     List instVarGetArgs2 = new TypedList(new LinkedList(), Expr.class, false);
		     List instVarGetArgs3 = new TypedList(new LinkedList(), Expr.class, false);
		     instVarGetArgs2.add(nf.This(null));
		     instVarGetArgs2.add(nf.StringLit(null, fi.name()+"_old"));
		     Expr e1 = nf.Call(null, nf.CanonicalTypeNode(null, ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "instVarRel_log", instVarGetArgs2);
		     instVarGetArgs3.add(nf.Field(null, nf.This(null), "old"));
		     instVarGetArgs3.add(nf.Field(null, nf.This(null), fi.name()));
		     Expr e2 = nf.Call(null, e1, "put_log", instVarGetArgs3);
		     relationizeOldMtdBody.add(nf.Eval(null, e2));		     
		     // have to do deep relationizing for reference types... 

		     // HACK FIXME:
			    try {
				
				ClassType tt = (ClassType) ts.typeForName(((AmbTypeNode) fi.type()).name());
				if (JL5Flags.isEnumModifier(tt.flags())) {
				    isEnumFd = true;		      
				}
			    } catch (Exception ex) {}
			    
			    if (fi.isReferenceType() && !isEnumFd) {
				Expr fieldExpr1 = nf.Field(null, nf.This(null), fi.name());
				Expr ifC1 = nf.Binary(null, fieldExpr1, Binary.NE, nf.NullLit(null));
				//Stmt ifT1 = nf.Block(null, relationizeOldMtdIfBody);
				//relationizeOldMtdBody.add(nf.JL5If(null, ifC1, ifT1, null));
				Expr fieldExpr = nf.Field(null, nf.This(null), fi.name());
				
				Expr ifC = nf.Binary(null, fieldExpr, Binary.NE, nf.NullLit(null));
				Stmt ifT = nf.Eval(null, nf.Call(null, fieldExpr,  "relationize", emptyArgs));
				relationizeMtdSubBody.add(nf.JL5If(null, ifC, ifT, null));

				Stmt ifT2 = nf.Eval(null, nf.Assign(null, nf.Field(null, nf.Local(null, "res"), fi.name()), Assign.ASSIGN, nf.Call(null, nf.Field(null, nf.This(null), fi.name()), "clone", emptyArgs)));
				cloneBody.add(nf.JL5If(null, ifC1, ifT2, null));
			    } else {
				//relationizeOldMtdBody.addAll(relationizeOldMtdIfBody);
				cloneBody.add(nf.Eval(null, nf.Assign(null, nf.Field(null, nf.Local(null, "res"), fi.name()), Assign.ASSIGN, nf.Field(null, nf.This(null), fi.name()))));
			    }			    			   
		 }
	     }			    
	 }
	 
     }

     public JL5MethodDecl makeFieldClosureMethod (AmbTypeNode cl, AmbTypeNode tn, AmbTypeNode asettn) throws Exception {

	 List extraMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, nf.CanonicalTypeNode(null, ts.Class()), "c", nf.ClassLit(null, cl)));
	 List frms = new TypedList(new LinkedList(), Formal.class, false);
	 frms.add(nf.JL5Formal(null, emptyFlags, nf.CanonicalTypeNode(null, ts.Boolean()), "isReflexive"));
	 TypeNode strtn = nf.ArrayTypeNode(null, nf.CanonicalTypeNode(null, ts.String()));
	 frms.add(nf.JL5Formal(null, emptyFlags, strtn, "fieldNs", true));
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, asettn, "res", nf.JL5New(null, asettn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, asettn, "unExpanded", nf.JL5New(null, asettn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, cl, "n", nf.This(null)));
	 List argsW = new TypedList(new LinkedList(), Expr.class, false);
	 argsW.add(nf.Local(null, "n"));
	 extraMtdBody.add(nf.Eval(null, nf.Call(null, nf.Local(null, "unExpanded"), "add", argsW)));
	 
	 List tryBody = new TypedList(new LinkedList(), Stmt.class, false);
	 List catches = new TypedList(new LinkedList(), Catch.class, false);
	 List catchBody = new TypedList(new LinkedList(), Stmt.class, false);
	 catchBody.add(nf.Eval(null, nf.Call(null, nf.Local(null,"rte"), "printStackTrace",
					     new TypedList(new LinkedList(), Expr.class, false))));
	 Block catchBlock = nf.Block(null,catchBody);
	 catches.add(nf.JL5Catch(null, nf.JL5Formal(null,  emptyFlags, nf.CanonicalTypeNode(null, ts.Exception()), "rte"), catchBlock));
	 List argsW2 = new TypedList(new LinkedList(), Expr.class, false);
	 List argsW0 = new TypedList(new LinkedList(), Expr.class, false);
	 argsW2.add(nf.This(null));
	 
	 List whileLoopStmts = new TypedList(new LinkedList(), Stmt.class, false);
	 whileLoopStmts.add(nf.Eval(null, nf.Assign(null, nf.Local(null, "n"), Assign.ASSIGN, nf.Call(null, nf.Call(null, nf.Local(null, "unExpanded"), "iterator", argsW0), "next", argsW0))));
	 whileLoopStmts.add(nf.Eval(null, nf.Call(null, nf.Local(null, "unExpanded"), "remove", argsW)));
	 whileLoopStmts.add(nf.Eval(null, nf.Call(null, nf.Local(null, "res"), "add", argsW)));
	 List fldgt = new TypedList(new LinkedList(), TypeNode.class, false);
	 AmbTypeNode fldtn = nf.AmbTypeNode(null, "java.lang.reflect.Field");
	 fldgt.add(fldtn);
	 AmbTypeNode afldtn = nf.JL5AmbTypeNode(null, ((AmbTypeNode)tn).qual(), ((AmbTypeNode)tn).name(), fldgt);
	 tryBody.add(nf.JL5LocalDecl(null, emptyFlags, afldtn, "fields", nf.JL5New(null, afldtn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
	 List forLoop1VarD = new TypedList(new LinkedList(), LocalDecl.class, false);
	 forLoop1VarD.add(nf.JL5LocalDecl(null, emptyFlags, nf.CanonicalTypeNode(null, ts.String()), "fN", null));
	 List forLoop1Stmts = new TypedList(new LinkedList(), Stmt.class, false);
	 List argsW1 = new TypedList(new LinkedList(), Expr.class, false);
	 List argsW1a = new TypedList(new LinkedList(), Expr.class, false);
	 argsW1a.add(nf.Local(null, "fN"));
	 argsW1.add(nf.Call(null, nf.Local(null, "c"), "getField", argsW1a));
	 forLoop1Stmts.add(nf.Eval(null, nf.Call(null, nf.Local(null, "fields"), "add", argsW1)));
	 Stmt forLoop1Body = nf.Block(null, forLoop1Stmts);
	 Stmt forLoop1 = nf.ExtendedFor(null, forLoop1VarD, nf.Local(null, "fieldNs"), forLoop1Body);			
	 tryBody.add(forLoop1);
	 
	 List forLoop2VarD = new TypedList(new LinkedList(), LocalDecl.class, false);
	 forLoop2VarD.add(nf.JL5LocalDecl(null, emptyFlags, fldtn, "f", null));
	 
	 List forLoop2Stmts = new TypedList(new LinkedList(), Stmt.class, false);
	 
	 List argsW2a = new TypedList(new LinkedList(), Expr.class, false);
	 
	 argsW2a.add(nf.Local(null, "n"));
	 forLoop2Stmts.add(nf.JL5LocalDecl(null, emptyFlags, cl, "childN", nf.JL5Cast(null, cl, nf.Call(null, nf.Local(null, "f"), "get", argsW2a))));
	 Expr forLoop2Ife1 = nf.Binary(null, nf.Local(null, "childN"), Binary.NE, nf.NullLit(null));
	 
	 List argsW2b = new TypedList(new LinkedList(), Expr.class, false);
	 argsW2b.add(nf.Local(null, "childN"));
	 
	 Stmt forLoop2Ife2 = nf.Eval(null, nf.Call(null, nf.Local(null, "unExpanded"), "add", argsW2b));			
	 forLoop2Stmts.add(nf.JL5If(null, forLoop2Ife1, forLoop2Ife2, null));
	 
	 Stmt forLoop2Body = nf.Block(null, forLoop2Stmts);
	 Stmt forLoop2 = nf.ExtendedFor(null, forLoop2VarD, nf.Local(null, "fields"), forLoop2Body);
	 whileLoopStmts.add(forLoop2);
	 Block whileLoopBody = nf.Block(null, whileLoopStmts);
	 tryBody.add(nf.While(null, nf.Binary(null, nf.Call(null, nf.Local(null, "unExpanded"), "size", argsW0), Binary.GT, nf.IntLit(null, IntLit.INT, 0)), whileLoopBody));
	 tryBody.add(nf.JL5If(null, nf.Unary(null, Unary.NOT, nf.Local(null,"isReflexive")), nf.Eval(null, nf.Call(null, nf.Local(null, "res"), "remove", argsW2)), null));
	 Block tryBlock = nf.Block(null, tryBody);
	 extraMtdBody.add(nf.Try(null, tryBlock, catches));
	 extraMtdBody.add(nf.JL5Return(null, nf.Local(null,"res")));
	 Block extraMtdBlock = nf.Block(null, extraMtdBody);
	 return nf.JL5MethodDecl(null, emptyFlags, asettn, "fieldsClosure", frms, new TypedList(new LinkedList(), TypeNode.class, false), extraMtdBlock, new TypedList(new LinkedList(), TypeNode.class, false));
	 
     }

     public JL5MethodDecl makeMultiFieldsMethod (AmbTypeNode cl, AmbTypeNode tn, AmbTypeNode asettn) throws Exception {

	 List extraMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, nf.CanonicalTypeNode(null, ts.Class()), "c", nf.ClassLit(null, cl)));
	 List frms = new TypedList(new LinkedList(), Formal.class, false);
	 TypeNode strtn = nf.ArrayTypeNode(null, nf.CanonicalTypeNode(null, ts.String()));
	 frms.add(nf.JL5Formal(null, emptyFlags, strtn, "fieldNs", true));
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, asettn, "res", nf.JL5New(null, asettn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
	 
	 List tryBody = new TypedList(new LinkedList(), Stmt.class, false);
	 List catches = new TypedList(new LinkedList(), Catch.class, false);
	 List catchBody = new TypedList(new LinkedList(), Stmt.class, false);
	 catchBody.add(nf.Eval(null, nf.Call(null, nf.Local(null,"rte"), "printStackTrace",
					     new TypedList(new LinkedList(), Expr.class, false))));
	 Block catchBlock = nf.Block(null,catchBody);
	 catches.add(nf.JL5Catch(null, nf.JL5Formal(null,  emptyFlags, nf.CanonicalTypeNode(null, ts.Exception()), "rte"), catchBlock));	 
	 AmbTypeNode fldtn = nf.AmbTypeNode(null, "java.lang.reflect.Field");
	 List forLoop1VarD = new TypedList(new LinkedList(), LocalDecl.class, false);
	 forLoop1VarD.add(nf.JL5LocalDecl(null, emptyFlags, nf.CanonicalTypeNode(null, ts.String()), "fN", null));
	 List forLoop1Stmts = new TypedList(new LinkedList(), Stmt.class, false);
	 List argsW1a = new TypedList(new LinkedList(), Expr.class, false);
	 List argsW1b = new TypedList(new LinkedList(), Expr.class, false);
	 List argsW2a = new TypedList(new LinkedList(), Expr.class, false);	
	 argsW1a.add(nf.Local(null, "fN"));
	 forLoop1Stmts.add(nf.JL5LocalDecl(null, emptyFlags, fldtn, "f", nf.Call(null, nf.Local(null, "c"), "getField", argsW1a)));
	 argsW2a.add(nf.This(null));
	 argsW1b.add(nf.Local(null, "n"));
	 forLoop1Stmts.add(nf.JL5LocalDecl(null, emptyFlags, cl, "n", nf.JL5Cast(null, cl, nf.Call(null, nf.Local(null, "f"), "get", argsW2a))));

	 Expr forLoop2Ife1 = nf.Binary(null, nf.Local(null, "n"), Binary.NE, nf.NullLit(null));	 	 
	 Stmt forLoop2Ife2 = nf.Eval(null, nf.Call(null, nf.Local(null, "res"), "add", argsW1b)); 
	 
	 forLoop1Stmts.add(nf.JL5If(null, forLoop2Ife1, forLoop2Ife2, null));
	 Stmt forLoop1Body = nf.Block(null, forLoop1Stmts);
	 Stmt forLoop1 = nf.ExtendedFor(null, forLoop1VarD, nf.Local(null, "fieldNs"), forLoop1Body);			
	 tryBody.add(forLoop1);
	 Block tryBlock = nf.Block(null, tryBody);
	 extraMtdBody.add(nf.Try(null, tryBlock, catches));
	 extraMtdBody.add(nf.JL5Return(null, nf.Local(null,"res")));
	 Block extraMtdBlock = nf.Block(null, extraMtdBody);
	 return nf.JL5MethodDecl(null, emptyFlags, asettn, "multiFields", frms, new TypedList(new LinkedList(), TypeNode.class, false), extraMtdBlock, new TypedList(new LinkedList(), TypeNode.class, false));
	 
     }
     
     public JL5MethodDecl makeSetMapFieldMethod(String fN, TypeNode fT, AmbTypeNode cl, AmbTypeNode tn, AmbTypeNode asettn, AmbTypeNode asettn2) throws Exception {
	 List extraMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
	 List frms = new TypedList(new LinkedList(), Formal.class, false);
	 frms.add(nf.JL5Formal(null, emptyFlags, asettn, "objs"));
	 TypeNode strtn = nf.ArrayTypeNode(null, nf.CanonicalTypeNode(null, ts.String()));
	 frms.add(nf.JL5Formal(null, emptyFlags, strtn, "fieldNs", true));
	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, asettn2, "res", nf.JL5New(null, asettn2, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));


	 List gt2 = new TypedList(new LinkedList(), TypeNode.class, false);
	 gt2.add(cl);
	 AmbTypeNode itrtn = nf.AmbTypeNode(null, "java.util.Iterator");
	 AmbTypeNode aitrtn = nf.JL5AmbTypeNode(null, ((AmbTypeNode)itrtn).qual(), ((AmbTypeNode)itrtn).name(), gt2);

	 extraMtdBody.add(nf.JL5LocalDecl(null, emptyFlags, aitrtn, "i", nf.Call(null, nf.Local(null, "objs"), "iterator", emptyArgs)));
	 List whileLoopStmts = new TypedList(new LinkedList(), Stmt.class, false);
	 List argsW2a = new TypedList(new LinkedList(), Expr.class, false);
	 
	 argsW2a.add(nf.Field(null, nf.Call(null, nf.Local(null, "i"), "next", emptyArgs), fN));
	 Stmt s1 = nf.Eval(null, nf.Call(null, nf.Local(null, "res"), "add", argsW2a));			
	 whileLoopStmts.add(s1);
	 Stmt whileLoopBody = nf.Block(null, whileLoopStmts);
	 extraMtdBody.add(nf.While(null, nf.Call(null, nf.Local(null, "i"), "hasNext", emptyArgs) , whileLoopBody));
	 extraMtdBody.add(nf.JL5Return(null, nf.Local(null,"res")));
	 Block extraMtdBlock = nf.Block(null, extraMtdBody);
	 List<Flags> fs2 = new ArrayList<Flags>();
	 fs2.add(Flags.STATIC);
	 fs2.add(Flags.PUBLIC);

	 return nf.JL5MethodDecl(null, makeFlagAnnotations(fs2), asettn2, "setMap_"+fN, frms, new TypedList(new LinkedList(), TypeNode.class, false), extraMtdBlock, new TypedList(new LinkedList(), TypeNode.class, false));
     }


     public Expr makeESJLogPredBlockHelper(Expr e, List quantVarD, ESJLogPredMethodDecl m, boolean isComprehension) {
     	    if (e instanceof FormulaBinary) {
	       	  Binary b = (Binary) e;
	       	  return nf.FormulaBinary(null,  makeESJLogPredBlockHelper(b.left(),quantVarD, m, isComprehension), b.operator(), makeESJLogPredBlockHelper(b.right(), quantVarD, m, isComprehension));
	    } else if (e instanceof CmpBinary) {
	       	  Binary b = (Binary) e;
	       	  return nf.CmpBinary(null, b.left(), b.operator(), b.right());
	    } else if (e instanceof Binary) {
	       	  Binary b = (Binary) e;
	       	  return nf.Binary(null, b.left(), b.operator(), b.right());
	    } else if (e instanceof Conditional) {
		  Conditional c = (Conditional) e;
		  return nf.JL5Conditional(null, c.cond(), makeESJLogPredBlockHelper(c.consequent(),quantVarD, m, isComprehension), makeESJLogPredBlockHelper(c.alternative(),quantVarD, m, isComprehension));
	    } else if (e instanceof ESJQuantifyExpr) {
	       	  ESJQuantifyExpr q = (ESJQuantifyExpr) e;
		  List quantVarD2 = new TypedList(new LinkedList(), JL5LocalDecl.class, false);
		  getQuantVarDs(q.quantClauseExpr().expr(), quantVarD2);		  
		  return nf.ESJLogQuantifyExpr(null, q.quantKind(), q.quantVarN(), q.quantVarD(), quantVarD2, q.quantListExpr(), makeESJLogPredBlockHelper(q.quantClauseExpr().expr(), quantVarD, m, isComprehension), m, isComprehension);
	    } else {
	      	   return e;
	    }
     }

     // FIXME
     void propogateQuantVarDs(Expr quantClauseExpr, List quantVarD) {	       
	 if (quantClauseExpr instanceof FormulaBinary) {
	     FormulaBinary b = (FormulaBinary) quantClauseExpr;
	     propogateQuantVarDs(b.left(), quantVarD);
	     propogateQuantVarDs(b.right(), quantVarD);
	 } if (quantClauseExpr instanceof Conditional) {
	     Conditional c = (Conditional) quantClauseExpr;
	     propogateQuantVarDs(c.consequent(), quantVarD);
	     propogateQuantVarDs(c.alternative(), quantVarD);
	 } else if (quantClauseExpr instanceof ESJQuantifyExpr)
	     ((ESJQuantifyExpr) quantClauseExpr).quantVarD2(quantVarD);
     }

     // FIXME
     void getQuantVarDs(Expr e, List quantVarD2) {
	 if (e instanceof FormulaBinary) {
	     FormulaBinary b = (FormulaBinary) e;
	     getQuantVarDs(b.left(), quantVarD2);
	     getQuantVarDs(b.right(), quantVarD2);		      
	 } else if (e instanceof Conditional) {
	     Conditional c = (Conditional) e;
	     getQuantVarDs(c.consequent(), quantVarD2);
	     getQuantVarDs(c.alternative(), quantVarD2);		      
	 } else if (e instanceof ESJQuantifyExpr) {
	     for (JL5LocalDecl d : (List<JL5LocalDecl>) ((ESJQuantifyExpr) e).quantVarD()) {
		 JL5LocalDecl dn = nf.JL5LocalDecl(null, emptyFlags, d.type(), d.name(), null);
		 dn = (JL5LocalDecl) dn.localInstance(ts.localInstance(null, Flags.NONE,
								       d.type().type(), d.name()));
		 quantVarD2.add(dn);
	     }
	 }
     }

     FlagAnnotations makeFlagAnnotations() {
     	      List<Flags> fs = new ArrayList<Flags>();
	      fs.add(Flags.NONE);
     	      return makeFlagAnnotations(fs);
     }

     FlagAnnotations makeFlagAnnotations(List<Flags> fs) {
	      FlagAnnotations fl2 = new FlagAnnotations(); 
	      for (Flags f: fs)
              	  fl2.classicFlags(f);
              fl2.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
	      return fl2;
     }	      


:}
scan with {: return nextSymbol(); :};
terminal Token BOOLEAN;
terminal Token BYTE, SHORT, INT, LONG, CHAR;
terminal Token FLOAT, DOUBLE;
terminal Token LBRACK, RBRACK;
terminal Identifier IDENTIFIER;
terminal Token DOT;
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ;
terminal Token LPAREN, RPAREN, COLON;
terminal Token PACKAGE;
terminal Token IMPORT;
terminal Token PUBLIC, PROTECTED, PRIVATE;
terminal Token STATIC;
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS;
terminal Token EXTENDS;
terminal Token IMPLEMENTS;
terminal Token VOID;
terminal Token THROWS;
terminal Token THIS, SUPER;
terminal Token INTERFACE;
terminal Token IF, ELSE;
terminal Token SWITCH;
terminal Token CASE, DEFAULT;
terminal Token DO, WHILE;
terminal Token FOR;
terminal Token BREAK;
terminal Token CONTINUE;
terminal Token RETURN;
terminal Token THROW;
terminal Token TRY;
terminal Token CATCH;
terminal Token FINALLY;
terminal Token NEW;
terminal Token PLUSPLUS;
terminal Token MINUSMINUS;
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT;
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF;
terminal Token EQEQ, NOTEQ;
terminal Token AND;
terminal Token XOR;
terminal Token OR;
terminal Token ANDAND;
terminal Token OROR;
terminal Token QUESTION;
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ;
terminal Token ANDEQ, XOREQ, OREQ;
terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL;
terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL_BD;
terminal polyglot.lex.LongLiteral LONG_LITERAL;
terminal polyglot.lex.LongLiteral LONG_LITERAL_BD;
terminal polyglot.lex.DoubleLiteral DOUBLE_LITERAL;
terminal polyglot.lex.FloatLiteral FLOAT_LITERAL;
terminal polyglot.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal polyglot.lex.CharacterLiteral CHARACTER_LITERAL;
terminal polyglot.lex.StringLiteral STRING_LITERAL;
terminal polyglot.lex.NullLiteral NULL_LITERAL;
terminal Token STRICTFP;
terminal Token ASSERT;
terminal CONST, GOTO;
non terminal SourceFile goal;
non terminal polyglot.ast.Lit literal;
non terminal polyglot.ast.Lit boundary_literal;
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode class_type, interface_type;
non terminal TypeNode array_type;
non terminal Name name, simple_name, qualified_name;
non terminal SourceFile compilation_unit;
non terminal PackageNode package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal Import import_declaration;
non terminal Import single_type_import_declaration;
non terminal Import type_import_on_demand_declaration;
non terminal ClassDecl type_declaration;
non terminal Flags modifier;
non terminal ClassDecl class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal ClassBody class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal List class_body_declaration, class_member_declaration;
non terminal List field_declaration;
non terminal List variable_declarators;
non terminal VarDeclarator variable_declarator;
non terminal VarDeclarator variable_declarator_id;
non terminal Expr variable_initializer;
non terminal MethodDecl method_declaration, method_header;
non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal Formal formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;
non terminal Block method_body;
non terminal Block static_initializer;
non terminal ConstructorDecl constructor_declaration;
non terminal Block constructor_body;
non terminal ConstructorCall explicit_constructor_invocation;
non terminal ClassDecl interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal ClassBody interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal List interface_member_declaration;
non terminal List constant_declaration;
non terminal MethodDecl abstract_method_declaration;
non terminal ArrayInit array_initializer;
non terminal List variable_initializers;
non terminal Block block;
non terminal List block_statements_opt, block_statements;
non terminal List block_statement;
non terminal List local_variable_declaration_statement;
non terminal List local_variable_declaration;
non terminal Stmt statement, statement_no_short_if;
non terminal Stmt statement_without_trailing_substatement;
non terminal Empty empty_statement;
non terminal Labeled labeled_statement, labeled_statement_no_short_if;
non terminal Stmt expression_statement;
non terminal Expr statement_expression;
non terminal If if_then_statement;
non terminal If if_then_else_statement, if_then_else_statement_no_short_if;
non terminal Switch switch_statement;
non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;
non terminal Case switch_label;
non terminal While while_statement, while_statement_no_short_if;
non terminal Do do_statement;
non terminal For for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal Name identifier_opt;
non terminal Branch break_statement, continue_statement;
non terminal Return return_statement;
non terminal Throw throw_statement;
non terminal Synchronized synchronized_statement;
non terminal Try try_statement;
non terminal List catches_opt, catches;
non terminal Catch catch_clause;
non terminal Block finally;
non terminal Assert assert_statement;
non terminal Expr primary, primary_no_new_array;
non terminal Expr class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal NewArray array_creation_expression;
non terminal List dim_exprs;
non terminal Expr dim_expr;
non terminal Integer dims_opt, dims;
non terminal Field field_access;
non terminal Call method_invocation;
non terminal ArrayAccess array_access;
non terminal Expr postfix_expression;
non terminal Unary postincrement_expression, postdecrement_expression;
non terminal Expr unary_expression, unary_expression_not_plus_minus;
non terminal Unary preincrement_expression, predecrement_expression;
non terminal Cast cast_expression;
non terminal Expr multiplicative_expression, additive_expression;
non terminal Expr shift_expression, relational_expression, equality_expression;
non terminal Expr and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expr conditional_and_expression, conditional_or_expression;
non terminal Expr conditional_expression, assignment_expression;
non terminal Expr assignment;
non terminal Expr left_hand_side;
non terminal Assign.Operator assignment_operator;
non terminal Expr expression_opt, expression;
non terminal Expr constant_expression;
terminal ELLIPSIS;
terminal ENUM;
terminal AT;
non terminal Import static_single_type_import_declaration;
non terminal Import static_type_import_on_demand_declaration;
non terminal ClassBody class_body_opt;
non terminal ClassDecl enum_declaration;
non terminal ClassBody enum_body;
non terminal List enum_constants_opt;
non terminal List enum_constants;
non terminal EnumConstantDecl enum_constant;
non terminal List enum_arguments_opt, enum_body_declarations_opt;
non terminal MethodDeclarator method_declarator;
non terminal ConstructorDeclarator constructor_declarator;
non terminal ExtendedFor foreach_statement, foreach_statement_no_short_if;
non terminal NewArray array_creation_init;
non terminal TypeNode class_or_interface;
non terminal Name type_variable;
non terminal List type_arguments, type_arguments_opt;
non terminal List type_argument_list;
non terminal List type_argument_list_1;
non terminal TypeNode reference_type_1;
non terminal List type_argument_list_2;
non terminal TypeNode reference_type_2;
non terminal List type_argument_list_3;
non terminal TypeNode reference_type_3;
non terminal List type_parameters, type_parameters_opt;
non terminal TypeNode type_parameter;
non terminal List type_parameter_list;
non terminal TypeNode type_parameter_1;
non terminal List type_parameter_list_1;
non terminal List type_bound, type_bound_opt;
non terminal List type_bound_1;
non terminal List additional_bound_list, additional_bound_list_opt;
non terminal List additional_bound_list_1;
non terminal TypeNode additional_bound;
non terminal TypeNode additional_bound_1;
non terminal TypeNode wildcard, wildcard_1, wildcard_2, wildcard_3;
non terminal TypeNode type_argument, type_argument_1, type_argument_2, type_argument_3;
non terminal Expr instanceof_expression;
non terminal Expr postfix_expression_nn;
non terminal Expr unary_expression_nn;
non terminal Expr unary_expression_not_plus_minus_nn;
non terminal Expr multiplicative_expression_nn;
non terminal Expr additive_expression_nn;
non terminal Expr shift_expression_nn;
non terminal Expr relational_expression_nn;
non terminal Expr instanceof_expression_nn;
non terminal Expr equality_expression_nn;
non terminal Expr and_expression_nn;
non terminal Expr exclusive_or_expression_nn;
non terminal Expr inclusive_or_expression_nn;
non terminal Expr conditional_and_expression_nn;
non terminal Expr conditional_or_expression_nn;
non terminal Expr conditional_expression_nn;
non terminal Expr assignment_expression_nn;
non terminal Expr expression_nn;
non terminal ClassBody annotation_body;
non terminal List annotation_type_element_declarations_opt;
non terminal List annotation_type_element_declarations;
non terminal List annotation_type_element_declaration;
non terminal Expr element_value;
non terminal Expr default_value_opt;
non terminal ElementValuePair element_value_pair;
non terminal List element_value_pairs, element_value_pairs_opt;
non terminal AnnotationElem annotation;
non terminal AnnotationElem marker_annotation, single_element_annotation, normal_annotation;
non terminal modifier_or_annotation;
non terminal FlagAnnotations modifiers_or_annotations;
non terminal FlagAnnotations modifiers_or_annotations_opt;
non terminal ArrayInit element_value_array_initializer;
non terminal List element_values;
terminal Token ESJENUM;
terminal Token SPEC;
terminal Token ALLOY;
terminal Token ENSURES;
terminal Token ENSURED;
terminal Token MODIFIESFIELDS;
terminal Token MODIFIESOBJECTS;
terminal Token SOME;
terminal Token ALL;
terminal Token NO;
terminal Token ONE;
terminal Token LONE;
non terminal ClassDecl esj_enum_declaration;
non terminal JL5MethodDecl fn_method_header;
non terminal ESJEnsuredMethodDecl ensured_method_header;
non terminal List fn_method_declaration, ensured_method_declaration;
non terminal Block fn_method_body, fn_block;
non terminal List fn_block_statements;
non terminal Return fn_statement;
non terminal Expr quantify_expression, comprehension_expression, quant_list_expr, ensures_opt, ensures_clause;
non terminal FormulaBinary.Operator quant_kind;
non terminal FormulaBinary.Operator closure_kind;
non terminal List fields_closure, fields_closure_multi, identifiers_union, modifies_fields_opt, modifiableFields, modifiableFields_list;
non terminal Expr modifies_objects_opt, modifiableObjects;
non terminal ESJEnsuredClassDecl ensured_class_declaration;
non terminal Expr predicate_expr, conditional_predicate_expr;
non terminal Expr or_predicate_expr;
non terminal Expr orPredExpr_opt;
non terminal Expr and_predicate_expr;
non terminal Expr andPredExpr_opt;
non terminal Expr equality_predicate_expr;
non terminal Binary.Operator equality_predicate_op;
non terminal Expr relational_predicate_expr;
non terminal Binary.Operator relational_predicate_op;
non terminal Expr additive_predicate_expr;
non terminal Binary.Operator additive_predicate_op;
non terminal Expr multiplicative_predicate_expr;
non terminal Expr unary_predicate_expr;
non terminal Expr atomic_predicate_expr;
non terminal Expr formal_or_field_access;
non terminal Receiver field_prefix;
non terminal Expr predicate_literal;
non terminal TypeNode esj_type, esj_reference_type, esj_primitive_type, esj_int_type;
non terminal List esj_field_declaration;


start with goal;

goal ::=
    compilation_unit:a {:
                      
                       if (parser.eq.hasErrors()) RESULT = null;
               else RESULT = a; 
                       
                       :};

literal ::=
    INTEGER_LITERAL:a {:
                     
                      RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue()); 
                      
                      :}
 |  LONG_LITERAL:a {:
                  
                   RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                     a.getValue().longValue()); 
                   
                   :}
 |  DOUBLE_LITERAL:a {:
                    
                     RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.DOUBLE,
                                           a.getValue().doubleValue()); 
                     
                     :}
 |  FLOAT_LITERAL:a {:
                   
                    RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.FLOAT,
                                           a.getValue().floatValue()); 
                    
                    :}
 |  BOOLEAN_LITERAL:a {:
                     
                      RESULT = parser.nf.BooleanLit(parser.pos(a),
                                         a.getValue().booleanValue()); 
                      
                      :}
 |  CHARACTER_LITERAL:a {:
                       
                        RESULT = parser.nf.CharLit(parser.pos(a),
                      a.getValue().charValue()); 
                        
                        :}
 |  STRING_LITERAL:a {:
                    
                     RESULT = parser.nf.StringLit(parser.pos(a), a.getValue()); 
                     
                     :}
 |  NULL_LITERAL:a {:   RESULT = parser.nf.NullLit(parser.pos(a));   :};

boundary_literal ::=
    INTEGER_LITERAL_BD:a {:
                        
                         RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue()); 
                         
                         :}
 |  LONG_LITERAL_BD:a {:
                     
                      RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                     a.getValue().longValue()); 
                      
                      :};

type ::=
    primitive_type:a {:   RESULT = a;   :}
 |  reference_type:a {:   RESULT = a;   :};

primitive_type ::=
    numeric_type:a {:   RESULT = a;   :}
 |  BOOLEAN:a {:
             
              RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean()); 
              
              :};

numeric_type ::=
    integral_type:a {:   RESULT = a;   :}
 |  floating_point_type:a {:   RESULT = a;   :};

integral_type ::=
    BYTE:a {:
          
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Byte()); 
           
           :}
 |  CHAR:a {:
          
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Char()); 
           
           :}
 |  SHORT:a {:
           
            RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Short()); 
            
            :}
 |  INT:a {:
         
          RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Int()); 
          
          :}
 |  LONG:a {:
          
           RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Long()); 
           
           :};

floating_point_type ::=
    FLOAT:a {:
           
            RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Float()); 
            
            :}
 |  DOUBLE:a {:
            
             RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Double()); 
             
             :};

reference_type ::=
    class_or_interface_type:a {:   RESULT = a;   :}
 |  array_type:a {:   RESULT = a;   :};

class_or_interface_type ::=
    class_or_interface:a {:   RESULT = a;   :}
 |  class_or_interface:a LT:b type_argument_list_1:c {:
                                                    
                                                     RESULT = parser.nf.JL5AmbTypeNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c); 
                                                     
                                                     :};

class_type ::=
    class_or_interface_type:a {:   RESULT = a;   :};

interface_type ::=
    class_or_interface_type:a {:   RESULT = a;   :};

array_type ::=
    primitive_type:a dims:b {:
                           
                            RESULT = parser.array(a, b.intValue()); 
                            
                            :}
 |  name:a dims:b {:
                 
                  RESULT = parser.array(a.toType(), b.intValue()); 
                  
                  :}
 |  class_or_interface:a LT type_argument_list_1:b DOT name:c dims:d {:
                                                                    
                                                                     RESULT = parser.array(parser.nf.AmbTypeNode(parser.pos(a, c), parser.nf.JL5AmbQualifierNode(parser.pos(a, b), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), b), c.toString()), d.intValue()); 
                                                                     
                                                                     :}
 |  class_or_interface:a LT type_argument_list_1:b dims:c {:
                                                         
                                                          RESULT = parser.array(parser.nf.JL5AmbTypeNode(parser.pos(a, b), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), b), c.intValue()); 
                                                          
                                                          :};

name ::=
    simple_name:a {:   RESULT = a;   :}
 |  qualified_name:a {:   RESULT = a;   :};

simple_name ::=
    IDENTIFIER:a {:
                
                 RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); 
                 
                 :};

qualified_name ::=
    name:a DOT IDENTIFIER:b {:
                           
                            RESULT = new JL5Name(parser, parser.pos(a, b), a, b.getIdentifier()); 
                            
                            :};

compilation_unit ::=
    package_declaration_opt:a import_declarations_opt:b type_declarations_opt:c {:
                                                                               
                                                                                RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()),
					     a, b, c);
	    
                                                                                
                                                                                :}
 |  error type_declarations_opt:c {:
                                 
                                  RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()),
					     null, Collections.EMPTY_LIST, c);
	    
                                  
                                  :};

package_declaration_opt ::=
    package_declaration:a {:   RESULT = a;   :}
 |  {:   RESULT = null;   :};

import_declarations_opt ::=
    import_declarations:a {:   RESULT = a;   :}
 |  {:
   
    RESULT = new TypedList(new LinkedList(), Import.class, false); 
    
    :};

type_declarations_opt ::=
    type_declarations:a {:   RESULT = a;   :}
 |  {:
   
    RESULT = new TypedList(new LinkedList(), TopLevelDecl.class, false); 
    
    :};

import_declarations ::=
    import_declaration:a {:
                        
                         List l = new TypedList(new LinkedList(), Import.class, false); 
               l.add(a);
               RESULT = l; 
                         
                         :}
 |  import_declarations:a import_declaration:b {:
                                              
                                               RESULT = a; 
               a.add(b); 
                                               
                                               :};

type_declarations ::=
    type_declaration:a {:
                       List l = new TypedList(new LinkedList(), TopLevelDecl.class, false); 
	      if (a != null) {
		  l.addAll(parser.addESJClassDecl(a));
	      }
	    RESULT = l; 
	   
                       :}
 |  type_declarations:a type_declaration:b {:
                                           RESULT = a;
              if (b != null)
		  a.addAll(parser.addESJClassDecl(b)); 
	   
                                           :};

package_declaration ::=
    PACKAGE name:a SEMICOLON {:   RESULT = a.toPackage();   :};

import_declaration ::=
    single_type_import_declaration:a {:   RESULT = a;   :}
 |  type_import_on_demand_declaration:a {:   RESULT = a;   :}
 |  static_single_type_import_declaration:a {:   RESULT = a;   :}
 |  static_type_import_on_demand_declaration:a {:   RESULT = a;   :};

single_type_import_declaration ::=
    IMPORT:a qualified_name:b SEMICOLON:c {:
                                         
                                          RESULT = parser.nf.Import(parser.pos(a, c), Import.CLASS, b.toString()); 
                                          
                                          :};

type_import_on_demand_declaration ::=
    IMPORT:a name:b DOT MULT SEMICOLON:c {:
                                        
                                         RESULT = parser.nf.Import(parser.pos(a, c), Import.PACKAGE, b.toString()); 
                                         
                                         :};

type_declaration ::=
    ensured_class_declaration:a {:  RESULT = a;  :}
 |  interface_declaration:a {:   RESULT = a;   :}
 |  SEMICOLON {:   RESULT = null;   :}
 |  esj_enum_declaration:a {:   RESULT = a;   :};

modifier ::=
    PUBLIC:a {:   RESULT = Flags.PUBLIC;   :}
 |  PROTECTED:a {:   RESULT = Flags.PROTECTED;   :}
 |  PRIVATE:a {:   RESULT = Flags.PRIVATE;   :}
 |  STATIC:a {:   RESULT = Flags.STATIC;   :}
 |  ABSTRACT:a {:   RESULT = Flags.ABSTRACT;   :}
 |  FINAL:a {:   RESULT = Flags.FINAL;   :}
 |  NATIVE:a {:   RESULT = Flags.NATIVE;   :}
 |  SYNCHRONIZED:a {:   RESULT = Flags.SYNCHRONIZED;   :}
 |  TRANSIENT:a {:   RESULT = Flags.TRANSIENT;   :}
 |  VOLATILE:a {:   RESULT = Flags.VOLATILE;   :}
 |  STRICTFP:a {:   RESULT = Flags.STRICTFP;   :};

class_declaration ::=
    modifiers_or_annotations_opt:a CLASS:b IDENTIFIER:c type_parameters_opt:d super_opt:e interfaces_opt:f class_body:g {:
                                                                                                                       
                                                                                                                        RESULT = parser.nf.JL5ClassDecl(parser.pos(b, g), a, c.getIdentifier(), e, f, g, d); 
                                                                                                                        
                                                                                                                        :};

super ::=
    EXTENDS class_type:a {:   RESULT = a;   :};

super_opt ::=
   
 |  super:a {:   RESULT = a;   :};

interfaces ::=
    IMPLEMENTS interface_type_list:a {:   RESULT = a;   :};

interfaces_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    
    :}
 |  interfaces:a {:   RESULT = a;   :};

interface_type_list ::=
    interface_type:a {:
                    
                     List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; 
                     
                     :}
 |  interface_type_list:a COMMA interface_type:b {:
                                                
                                                 RESULT = a;
               a.add(b); 
                                                 
                                                 :};

class_body ::=
    LBRACE:n class_body_declarations_opt:a RBRACE:b {:
                                                   
                                                    RESULT = parser.nf.JL5ClassBody(parser.pos(n, b), a); 
                                                    
                                                    :};

class_body_declarations_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    
    :}
 |  class_body_declarations:a {:   RESULT = a;   :};

class_body_declarations ::=
    class_body_declaration:a {:   RESULT = a;   :}
 |  class_body_declarations:a class_body_declaration:b {:
                                                      
                                                       RESULT = a;
               a.addAll(b); 
                                                       
                                                       :};

class_body_declaration ::=
    class_member_declaration:a {:   RESULT = a;   :}
 |  static_initializer:a {:
                        
                         List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.STATIC, a));
               RESULT = l; 
                         
                         :}
 |  constructor_declaration:a {:
                             
                              List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                              
                              :}
 |  block:a {:
           
            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.NONE, a));
               RESULT = l; 
            
            :}
 |  SEMICOLON {:
             
              List l = new TypedList(new LinkedList(), ClassMember.class, false);
               RESULT = l; 
              
              :}
 |  error SEMICOLON:a {:
                     
                      List l = new TypedList(new LinkedList(), ClassMember.class, false);
               RESULT = l; 
                      
                      :}
 |  error LBRACE:a {:
                  
                   List l = new TypedList(new LinkedList(), ClassMember.class, false);
               RESULT = l; 
                   
                   :};

class_member_declaration ::=
    esj_field_declaration:a {:  RESULT = a;  :}
 |  field_declaration:a {:   RESULT = a;   :}
 |  method_declaration:a {:
                        
                         List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                         
                         :}
 |  modifiers_or_annotations_opt:a CLASS:b IDENTIFIER:c type_parameters_opt:d super_opt:e interfaces_opt:f class_body:g {:
                                                                                                                       
                                                                                                                        List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.JL5ClassDecl(parser.pos(b, g), a, c.getIdentifier(), e, f, g, d));
           RESULT = l; 
                                                                                                                        
                                                                                                                        :}
 |  interface_declaration:a {:
                           
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                            
                            :}
 |  enum_declaration:a {:
                      
                       List l = new TypedList(new LinkedList(), ClassMember.class, false);
       l.add(a);
       RESULT = l; 
                       
                       :}
 |  fn_method_declaration:a {:  RESULT = a;  :}
 |  ensured_method_declaration:a {:  RESULT = a;  :};

field_declaration ::=
    modifiers_or_annotations_opt:a type:b variable_declarators:c SEMICOLON:e {:
                                                                            
                                                                             List l = new TypedList(new LinkedList(), ClassMember.class, false);
       for (Iterator i = c.iterator(); i.hasNext(); ) {
         VarDeclarator d = (VarDeclarator) i.next();
         l.add(parser.nf.JL5FieldDecl(parser.pos(b, e),
               a, parser.array(b, d.dims),
               d.name, d.init));
        }
        RESULT = l; 
                                                                             
                                                                             :};

variable_declarators ::=
    variable_declarator:a {:
                         
                          List l = new TypedList(new LinkedList(), VarDeclarator.class, false);
               l.add(a);
               RESULT = l; 
                          
                          :}
 |  variable_declarators:a COMMA variable_declarator:b {:
                                                      
                                                       RESULT = a;
               a.add(b); 
                                                       
                                                       :};

variable_declarator ::=
    variable_declarator_id:a {:   RESULT = a;   :}
 |  variable_declarator_id:a EQ variable_initializer:b {:
                                                      
                                                       RESULT = a;
               a.init = b; 
                                                       
                                                       :};

variable_declarator_id ::=
    IDENTIFIER:a {:
                
                 RESULT = new VarDeclarator(parser.pos(a),
                            a.getIdentifier()); 
                 
                 :}
 |  variable_declarator_id:a LBRACK RBRACK {:
                                          
                                           RESULT = a;
               a.dims++; 
                                           
                                           :};

variable_initializer ::=
    expression:a {:   RESULT = a;   :}
 |  array_initializer:a {:   RESULT = a;   :};

method_declaration ::=
    method_header:a method_body:b {:
                                 
                                  RESULT = (MethodDecl) a.body(b); 
                                  
                                  :};

method_header ::=
    modifiers_or_annotations_opt:a type:b method_declarator:c throws_opt:d {:
                                                                          
                                                                           RESULT = parser.nf.JL5MethodDecl(c.position(), a, parser.array(b, c.dims().intValue()), c.name(), c.formals(), d, null, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                           
                                                                           :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c type:d method_declarator:e throws_opt:f {:
                                                                                                       
                                                                                                        RESULT = parser.nf.JL5MethodDecl(e.position(), a, parser.array(d, e.dims().intValue()), e.name(), e.formals(), f, null, c); 
                                                                                                        
                                                                                                        :}
 |  modifiers_or_annotations_opt:a VOID:b method_declarator:c throws_opt:e {:
                                                                          
                                                                           RESULT = parser.nf.JL5MethodDecl(c.position(), a, parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), c.name(), c.formals(), e, null, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                           
                                                                           :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c VOID:d method_declarator:e throws_opt:f {:
                                                                                                       
                                                                                                        RESULT = parser.nf.JL5MethodDecl(e.position(), a, parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), e.name(), e.formals(), f, null, c); 
                                                                                                        
                                                                                                        :};

formal_parameter_list_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), Formal.class, false); 
    
    :}
 |  formal_parameter_list:a {:   RESULT = a;   :};

formal_parameter_list ::=
    formal_parameter:a {:
                      
                       List l = new TypedList(new LinkedList(), Formal.class, false);
               l.add(a);
               RESULT = l; 
                       
                       :}
 |  formal_parameter_list:a COMMA formal_parameter:b {:
                                                    
                                                     RESULT = a;
               a.add(b); 
                                                     
                                                     :};

formal_parameter ::=
    modifiers_or_annotations_opt:a type:b variable_declarator_id:c {:
                                                                  
                                                                   RESULT = parser.nf.JL5Formal(parser.pos(b, c, c), a,
                     parser.array(b, c.dims), c.name); 
                                                                   
                                                                   :}
 |  modifiers_or_annotations_opt:a type:b ELLIPSIS:c IDENTIFIER:d {:
                                                                 
                                                                  RESULT = parser.nf.JL5Formal(parser.pos(b, d, d), a, parser.nf.ArrayTypeNode(parser.pos(b), b), d.getIdentifier(), true);
        
                                                                  
                                                                  :};

throws_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    
    :}
 |  throws:a {:   RESULT = a;   :};

throws ::=
    THROWS class_type_list:a {:   RESULT = a;   :};

class_type_list ::=
    class_type:a {:
                
                 List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; 
                 
                 :}
 |  class_type_list:a COMMA class_type:b {:
                                        
                                         RESULT = a;
               a.add(b); 
                                         
                                         :};

method_body ::=
    block:a {:   RESULT = a;   :}
 |  SEMICOLON {:   RESULT = null;   :};

static_initializer ::=
    STATIC block:a {:   RESULT = a;   :};

constructor_declaration ::=
    modifiers_or_annotations_opt:a constructor_declarator:b throws_opt:c constructor_body:d {:
                                                                                           
              List args = new TypedList(new LinkedList(), Expr.class, false);
	      args.add(parser.nf.This(null));
	    if (! (d.statements().get(0) instanceof JL5ConstructorCall) || !(((JL5ConstructorCall) d.statements().get(0)).kind() == JL5ConstructorCall.THIS)) //FIXME
		d = d.append(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.Field(null, parser.nf.This(null), "allInstances"), "add", args))); 
              RESULT = parser.nf.JL5ConstructorDecl(b.position(), a, b.name(), b.formals(), c, d, new TypedList(new LinkedList(), TypeNode.class, false)); 
	   
                                                                                            :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c constructor_declarator:d throws_opt:e constructor_body:f {:
                                                                                                                         List args = new TypedList(new LinkedList(), Expr.class, false);
	      args.add(parser.nf.This(null));
              RESULT = parser.nf.JL5ConstructorDecl(d.position(), a, d.name(), d.formals(), e, f.append(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.Field(null, parser.nf.This(null), "allInstances"), "add", args))), c); 

           
                                                                                                                         :};

constructor_body ::=
    LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE:d {:
                                                                          
                                                                           List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           l.addAll(b);
           RESULT = parser.nf.Block(parser.pos(n, d), l); 
                                                                           
                                                                           :}
 |  LBRACE:n explicit_constructor_invocation:a RBRACE:d {:
                                                       
                                                        RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                                        
                                                        :}
 |  LBRACE:n block_statements:a RBRACE:d {:
                                        
                                         RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                         
                                         :}
 |  LBRACE:n RBRACE:d {:
                     
                      RESULT = parser.nf.Block(parser.pos(n, d), new TypedList(new LinkedList(), Stmt.class, false)); 
                      
                      :};

explicit_constructor_invocation ::=
    THIS:a LPAREN:b argument_list_opt:c RPAREN:d SEMICOLON:e {:
                                                            
                                                             RESULT = parser.nf.ThisCall(parser.pos(a, e), c); 
                                                             
                                                             :}
 |  type_arguments:a THIS:b LPAREN:c argument_list_opt:d RPAREN:e SEMICOLON:f {:
                                                                             
                                                                              RESULT = parser.nf.JL5ThisCall(parser.pos(a, f), d, a); 
                                                                              
                                                                              :}
 |  SUPER:a LPAREN:b argument_list_opt:c RPAREN:d SEMICOLON:e {:
                                                             
                                                              RESULT = parser.nf.SuperCall(parser.pos(a, e), c); 
                                                              
                                                              :}
 |  type_arguments:a SUPER:b LPAREN:c argument_list_opt:d RPAREN:e SEMICOLON:f {:
                                                                              
                                                                               RESULT = parser.nf.JL5SuperCall(parser.pos(a, f), d, a); 
                                                                               
                                                                               :}
 |  primary:a DOT:b SUPER:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g {:
                                                                             
                                                                              RESULT = parser.nf.SuperCall(parser.pos(a, g, c), a, e); 
                                                                              
                                                                              :}
 |  primary:a DOT:b type_arguments:c SUPER:d LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h {:
                                                                                              
                                                                                               RESULT = parser.nf.JL5SuperCall(parser.pos(a, h, d), a, f, c); 
                                                                                               
                                                                                               :}
 |  name:a DOT:b SUPER:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g {:
                                                                          
                                                                           RESULT = parser.nf.SuperCall(parser.pos(a, g, d), a.toExpr(), e); 
                                                                           
                                                                           :}
 |  name:a DOT:b type_arguments:c SUPER:d LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h {:
                                                                                           
                                                                                            RESULT = parser.nf.JL5SuperCall(parser.pos(a, h, d), a.toExpr(), f, c); 
                                                                                            
                                                                                            :}
 |  primary:a DOT:b THIS:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g {:
                                                                            
                                                                             RESULT = parser.nf.ThisCall(parser.pos(a, g, c), a, e); 
                                                                             
                                                                             :}
 |  primary:a DOT:b type_arguments:c THIS:d LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h {:
                                                                                             
                                                                                              RESULT = parser.nf.JL5ThisCall(parser.pos(a, h, d), a, f, c); 
                                                                                              
                                                                                              :}
 |  name:a DOT:b THIS:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g {:
                                                                         
                                                                          RESULT = parser.nf.ThisCall(parser.pos(a, g, d), a.toExpr(), e); 
                                                                          
                                                                          :}
 |  name:a DOT:b type_arguments:c THIS:d LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h {:
                                                                                          
                                                                                           RESULT = parser.nf.JL5ThisCall(parser.pos(a, h, d), a.toExpr(), f, c); 
                                                                                           
                                                                                           :};

interface_declaration ::=
    modifiers_or_annotations_opt:a INTERFACE:b IDENTIFIER:c type_parameters_opt:d extends_interfaces_opt:e interface_body:f {:
                                                                                                                           
                                                                                                                            a.classicFlags(Flags.INTERFACE);
           RESULT = parser.nf.JL5ClassDecl(parser.pos(b, f), a, c.getIdentifier(), null, e, f, d); 
                                                                                                                            
                                                                                                                            :}
 |  AT:a INTERFACE:b IDENTIFIER:c annotation_body:d {:
                                                   
                                                    List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(parser.nf.CanonicalTypeNode(parser.pos(a, d), parser.ts.Annotation()));
           FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.INTERFACE.set(JL5Flags.ANNOTATION));
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = parser.nf.JL5ClassDecl(parser.pos(a, d), fl, c.getIdentifier(), null, l, d, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                    
                                                    :}
 |  modifiers_or_annotations:a AT:b INTERFACE:c IDENTIFIER:d annotation_body:e {:
                                                                              
                                                                               List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Annotation()));
           a.classicFlags(Flags.INTERFACE.set(JL5Flags.ANNOTATION));
           RESULT = parser.nf.JL5ClassDecl(parser.pos(b, e), a, d.getIdentifier() ,null, l, e, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                               
                                                                               :};

extends_interfaces_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    
    :}
 |  extends_interfaces:a {:   RESULT = a;   :};

extends_interfaces ::=
    EXTENDS interface_type:a {:
                            
                             List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; 
                             
                             :}
 |  extends_interfaces:a COMMA interface_type:b {:
                                               
                                                RESULT = a;
               a.add(b); 
                                                
                                                :};

interface_body ::=
    LBRACE:n interface_member_declarations_opt:a RBRACE:d {:
                                                         
                                                          RESULT = parser.nf.JL5ClassBody(parser.pos(n, d), a); 
                                                          
                                                          :};

interface_member_declarations_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    
    :}
 |  interface_member_declarations:a {:   RESULT = a;   :};

interface_member_declarations ::=
    interface_member_declaration:a {:   RESULT = a;   :}
 |  interface_member_declarations:a interface_member_declaration:b {:
                                                                  
                                                                   RESULT = a;
               a.addAll(b); 
                                                                   
                                                                   :};

interface_member_declaration ::=
    constant_declaration:a {:   RESULT = a;   :}
 |  abstract_method_declaration:a {:
                                 
                                  List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                                  
                                  :}
 |  class_declaration:a {:
                       
                        List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                        
                        :}
 |  interface_declaration:a {:
                           
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; 
                            
                            :}
 |  SEMICOLON {:   RESULT = Collections.EMPTY_LIST;   :}
 |  enum_declaration:a {:
                      
                       List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                       
                       :};

constant_declaration ::=
    field_declaration:a {:   RESULT = a;   :};

abstract_method_declaration ::=
    method_header:a SEMICOLON {:   RESULT = a;   :};

array_initializer ::=
    LBRACE:n variable_initializers:a COMMA RBRACE:d {:
                                                   
                                                    RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); 
                                                    
                                                    :}
 |  LBRACE:n variable_initializers:a RBRACE:d {:
                                             
                                              RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); 
                                              
                                              :}
 |  LBRACE:n COMMA RBRACE:d {:
                           
                            RESULT = parser.nf.ArrayInit(parser.pos(n, d)); 
                            
                            :}
 |  LBRACE:n RBRACE:d {:
                     
                      RESULT = parser.nf.ArrayInit(parser.pos(n, d)); 
                      
                      :};

variable_initializers ::=
    variable_initializer:a {:
                          
                           List l = new TypedList(new LinkedList(), Expr.class, false);
           l.add(a);
           RESULT = l; 
                           
                           :}
 |  variable_initializers:a COMMA variable_initializer:b {:
                                                        
                                                         RESULT = a; a.add(b); 
                                                         
                                                         :};

block ::=
    LBRACE:n block_statements_opt:a RBRACE:d {:
                                            
                                             RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                             
                                             :}
 |  error RBRACE:d {:
                  
                   RESULT = parser.nf.Block(parser.pos(d),
                                        Collections.EMPTY_LIST); 
                   
                   :};

block_statements_opt ::=
    {:
     RESULT = new TypedList(new LinkedList(), Stmt.class, false);  
    :}
 |  block_statements:a {:   RESULT = a;   :};

block_statements ::=
    block_statement:a {:
                     
                      List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               RESULT = l; 
                      
                      :}
 |  block_statements:a block_statement:b {:
                                        
                                         RESULT = a;
               a.addAll(b); 
                                         
                                         :};

block_statement ::=
    local_variable_declaration_statement:a {:   RESULT = a;   :}
 |  statement:a {:
               
                List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               RESULT = l; 
                
                :}
 |  class_declaration:a {:
                       
                        List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
               RESULT = l; 
                        
                        :}
 |  enum_declaration:a {:
                      
                       List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           RESULT = l; 
                       
                       :}
 |  interface_declaration:a {:
                           
                            List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           RESULT = l; 
                            
                            :};

local_variable_declaration_statement ::=
    local_variable_declaration:a SEMICOLON {:   RESULT = a;   :};

local_variable_declaration ::=
    modifiers_or_annotations:a type:b variable_declarators:c {:
                                                            
                                                             RESULT = parser.variableDeclarators(b, c, a); 
                                                             
                                                             :}
 |  type:a variable_declarators:b {:
                                 
                                  FlagAnnotations fl = new FlagAnnotations(); 
               fl.classicFlags(Flags.NONE);
               fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
               RESULT = parser.variableDeclarators(a, b, fl); 
                                  
                                  :};

statement ::=
    statement_without_trailing_substatement:a {:   RESULT = a;   :}
 |  labeled_statement:a {:   RESULT = a;   :}
 |  if_then_statement:a {:   RESULT = a;   :}
 |  if_then_else_statement:a {:   RESULT = a;   :}
 |  while_statement:a {:   RESULT = a;   :}
 |  for_statement:a {:   RESULT = a;   :}
 |  error SEMICOLON:a {:   RESULT = parser.nf.Empty(parser.pos(a));   :}
 |  foreach_statement:a {:   RESULT = a;   :};

statement_no_short_if ::=
    statement_without_trailing_substatement:a {:   RESULT = a;   :}
 |  labeled_statement_no_short_if:a {:   RESULT = a;   :}
 |  if_then_else_statement_no_short_if:a {:   RESULT = a;   :}
 |  while_statement_no_short_if:a {:   RESULT = a;   :}
 |  for_statement_no_short_if:a {:   RESULT = a;   :}
 |  foreach_statement_no_short_if:a {:   RESULT = a;   :};

statement_without_trailing_substatement ::=
    block:a {:   RESULT = a;   :}
 |  empty_statement:a {:   RESULT = a;   :}
 |  expression_statement:a {:   RESULT = a;   :}
 |  switch_statement:a {:   RESULT = a;   :}
 |  do_statement:a {:   RESULT = a;   :}
 |  break_statement:a {:   RESULT = a;   :}
 |  continue_statement:a {:   RESULT = a;   :}
 |  return_statement:a {:   RESULT = a;   :}
 |  synchronized_statement:a {:   RESULT = a;   :}
 |  throw_statement:a {:   RESULT = a;   :}
 |  try_statement:a {:   RESULT = a;   :}
 |  assert_statement:a {:   RESULT = a;   :};

empty_statement ::=
    SEMICOLON:a {:   RESULT = parser.nf.Empty(parser.pos(a));   :};

labeled_statement ::=
    IDENTIFIER:a COLON statement:b {:
                                  
                                   RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b); 
                                   
                                   :};

labeled_statement_no_short_if ::=
    IDENTIFIER:a COLON statement_no_short_if:b {:
                                              
                                               RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b); 
                                               
                                               :};

expression_statement ::=
    statement_expression:a SEMICOLON:d {:
                                      
                                       RESULT = parser.nf.Eval(parser.pos(a, d), a); 
                                       
                                       :};

statement_expression ::=
    assignment:a {:   RESULT = a;   :}
 |  preincrement_expression:a {:   RESULT = a;   :}
 |  predecrement_expression:a {:   RESULT = a;   :}
 |  postincrement_expression:a {:   RESULT = a;   :}
 |  postdecrement_expression:a {:   RESULT = a;   :}
 |  method_invocation:a {:   RESULT = a;   :}
 |  class_instance_creation_expression:a {:   RESULT = a;   :};

if_then_statement ::=
    IF:n LPAREN expression:a RPAREN statement:b {:
                                               
                                                RESULT = parser.nf.JL5If(parser.pos(n, b), a, b, null); 
                                                
                                                :};

if_then_else_statement ::=
    IF:n LPAREN expression:a RPAREN statement_no_short_if:b ELSE statement:c {:
                                                                            
                                                                             RESULT = parser.nf.JL5If(parser.pos(n, c), a, b, c); 
                                                                             
                                                                             :};

if_then_else_statement_no_short_if ::=
    IF:n LPAREN expression:a RPAREN statement_no_short_if:b ELSE statement_no_short_if:c {:
                                                                                        
                                                                                         RESULT = parser.nf.JL5If(parser.pos(n, c), a, b, c); 
                                                                                         
                                                                                         :};

switch_statement ::=
    SWITCH:n LPAREN expression:a RPAREN switch_block:b {:
                                                      
                                                       RESULT = parser.nf.JL5Switch(parser.pos(n, b), a, b); 
                                                       
                                                       :};

switch_block ::=
    LBRACE switch_block_statement_groups:a switch_labels:b RBRACE {:
                                                                 
                                                                  RESULT = a;
               a.addAll(b); 
                                                                  
                                                                  :}
 |  LBRACE switch_block_statement_groups:a RBRACE {:   RESULT = a;   :}
 |  LBRACE switch_labels:a RBRACE {:   RESULT = a;   :}
 |  LBRACE RBRACE {:
                 
                  RESULT = new TypedList(new LinkedList(), SwitchElement.class, false); 
                  
                  :};

switch_block_statement_groups ::=
    switch_block_statement_group:a {:   RESULT = a;   :}
 |  switch_block_statement_groups:a switch_block_statement_group:b {:
                                                                  
                                                                   RESULT = a;
               a.addAll(b); 
                                                                   
                                                                   :};

switch_block_statement_group ::=
    switch_labels:a block_statements:b {:
                                      
                                       List l = new TypedList(new LinkedList(), SwitchElement.class, false);
               l.addAll(a); 
               l.add(parser.nf.SwitchBlock(parser.pos(a, b), b));
               RESULT = l; 
                                       
                                       :};

switch_labels ::=
    switch_label:a {:
                  
                   List l = new TypedList(new LinkedList(), Case.class, false);
               l.add(a);
               RESULT = l; 
                   
                   :}
 |  switch_labels:a switch_label:b {:
                                  
                                   RESULT = a;
               a.add(b); 
                                   
                                   :};

switch_label ::=
    CASE:n constant_expression:a COLON:d {:
                                        
                                         RESULT = parser.nf.JL5Case(parser.pos(n, d), a); 
                                         
                                         :}
 |  DEFAULT:n COLON:d {:
                     
                      RESULT = parser.nf.Default(parser.pos(n, d)); 
                      
                      :};

while_statement ::=
    WHILE:n LPAREN expression:a RPAREN statement:b {:
                                                  
                                                   RESULT = parser.nf.While(parser.pos(n, b), a, b); 
                                                   
                                                   :};

while_statement_no_short_if ::=
    WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b {:
                                                              
                                                               RESULT = parser.nf.While(parser.pos(n, b), a, b); 
                                                               
                                                               :};

do_statement ::=
    DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON:d {:
                                                                 
                                                                  RESULT = parser.nf.Do(parser.pos(n, d), a, b); 
                                                                  
                                                                  :};

for_statement ::=
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e for_update_opt:c RPAREN statement:d {:
                                                                                                          
                                                                                                           RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d); 
                                                                                                           
                                                                                                           :};

for_statement_no_short_if ::=
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e for_update_opt:c RPAREN statement_no_short_if:d {:
                                                                                                                      
                                                                                                                       RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d); 
                                                                                                                       
                                                                                                                       :};

for_init_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ForInit.class, false); 
    
    :}
 |  for_init:a {:   RESULT = a;   :};

for_init ::=
    statement_expression_list:a {:   RESULT = a;   :}
 |  local_variable_declaration:a {:
                                
                                 List l = new TypedList(new LinkedList(), ForInit.class, false);
               l.addAll(a);
               RESULT = l; 
                                 
                                 :};

for_update_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ForUpdate.class, false); 
    
    :}
 |  for_update:a {:   RESULT = a;   :};

for_update ::=
    statement_expression_list:a {:   RESULT = a;   :};

statement_expression_list ::=
    statement_expression:a {:
                          
                           List l = new TypedList(new LinkedList(), Eval.class, false);
               l.add(parser.nf.Eval(parser.pos(a), a));
               RESULT = l; 
                           
                           :}
 |  statement_expression_list:a COMMA statement_expression:b {:
                                                            
                                                             RESULT = a;
               a.add(parser.nf.Eval(parser.pos(a, b, b), b)); 
                                                             
                                                             :};

identifier_opt ::=
    {:   RESULT = null;   :}
 |  IDENTIFIER:a {:
                
                 RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); 
                 
                 :};

break_statement ::=
    BREAK:n identifier_opt:a SEMICOLON:d {:
                                        
                                         if (a == null)
                   RESULT = parser.nf.Break(parser.pos(n, d));
               else
                   RESULT = parser.nf.Break(parser.pos(n, d), a.toString()); 
                                         
                                         :};

continue_statement ::=
    CONTINUE:n identifier_opt:a SEMICOLON:d {:
                                           
                                            if (a == null)
                   RESULT = parser.nf.Continue(parser.pos(n, d));
               else
                   RESULT = parser.nf.Continue(parser.pos(n, d), a.toString()); 
                                            
                                            :};

return_statement ::=
    RETURN:n expression_opt:a SEMICOLON:d {:
                                         
                                          RESULT = parser.nf.JL5Return(parser.pos(n, d), a); 
                                          
                                          :};

throw_statement ::=
    THROW:n expression:a SEMICOLON:d {:
                                    
                                     RESULT = parser.nf.Throw(parser.pos(n, d), a); 
                                     
                                     :};

synchronized_statement ::=
    SYNCHRONIZED:n LPAREN expression:a RPAREN block:b {:
                                                     
                                                      RESULT = parser.nf.Synchronized(parser.pos(n, b), a, b); 
                                                      
                                                      :};

try_statement ::=
    TRY:n block:a catches:b {:
                           
                            RESULT = parser.nf.Try(parser.pos(n, b), a, b); 
                            
                            :}
 |  TRY:n block:a catches_opt:b finally:c {:
                                         
                                          RESULT = parser.nf.Try(parser.pos(n, c), a, b, c); 
                                          
                                          :};

catches_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), Catch.class, false); 
    
    :}
 |  catches:a {:   RESULT = a;   :};

catches ::=
    catch_clause:a {:
                  
                   List l = new TypedList(new LinkedList(), Catch.class, false);
               l.add(a);
               RESULT = l; 
                   
                   :}
 |  catches:a catch_clause:b {:
                            
                             RESULT = a;
               a.add(b); 
                             
                             :};

catch_clause ::=
    CATCH:n LPAREN formal_parameter:a RPAREN block:b {:
                                                    
                                                     RESULT = parser.nf.JL5Catch(parser.pos(n, b), a, b); 
                                                     
                                                     :};

finally ::=
    FINALLY block:a {:   RESULT = a;   :};

assert_statement ::=
    ASSERT:x expression:a SEMICOLON:d {:
                                     
                                      RESULT = parser.nf.JL5Assert(parser.pos(x, d), a, null); 
                                      
                                      :}
 |  ASSERT:x expression:a COLON expression:b SEMICOLON:d {:
                                                        
                                                         RESULT = parser.nf.JL5Assert(parser.pos(x, d), a, b); 
                                                         
                                                         :};

primary ::=
    primary_no_new_array:a {:   RESULT = a;   :}
 |  array_creation_expression:a {:   RESULT = a;   :};

primary_no_new_array ::=
    literal:a {:   RESULT = a;   :}
 |  THIS:a {:   RESULT = parser.nf.This(parser.pos(a));   :}
 |  LPAREN name:a RPAREN {:   RESULT = a.toExpr();   :}
 |  LPAREN expression_nn:a RPAREN {:   RESULT = a;   :}
 |  class_instance_creation_expression:a {:   RESULT = a;   :}
 |  field_access:a {:   RESULT = a;   :}
 |  method_invocation:a {:   RESULT = a;   :}
 |  array_access:a {:   RESULT = a;   :}
 |  name:a DOT:b THIS:c {:
                       
                        RESULT = parser.nf.This(parser.pos(a, c, c), a.toType()); 
                        
                        :}
 |  VOID:a DOT:b CLASS:c {:
                        
                         RESULT = parser.nf.ClassLit(parser.pos(a, c, c), parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Void())); 
                         
                         :}
 |  primitive_type:a DOT:b CLASS:c {:
                                  
                                   RESULT = parser.nf.ClassLit(parser.pos(a, c, c), a); 
                                   
                                   :}
 |  primitive_type:a dims:b DOT:c CLASS:d {:
                                         
                                          RESULT = parser.nf.ClassLit(parser.pos(a, d, d), parser.array(a, b.intValue())); 
                                          
                                          :}
 |  name:a DOT:b CLASS:c {:
                        
                         RESULT = parser.nf.ClassLit(parser.pos(a, c, c), a.toType()); 
                         
                         :}
 |  name:a dims:b DOT:c CLASS:d {:
                               
                                RESULT = parser.nf.ClassLit(parser.pos(a, d, d), parser.array(a.toType(), b.intValue())); 
                                
                                :};

class_instance_creation_expression ::=
    NEW:a class_or_interface_type:b LPAREN:c argument_list_opt:d RPAREN:e class_body_opt:f {:
                                                                                          
                                                                                           RESULT = parser.nf.JL5New(parser.pos(a), b, d, f, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                                           
                                                                                           :}
 |  NEW:a type_arguments:b class_or_interface_type:c LPAREN:d argument_list_opt:e RPAREN:f class_body_opt:g {:
                                                                                                           
                                                                                                            RESULT = parser.nf.JL5New(parser.pos(a), c, e, g, b); 
                                                                                                            
                                                                                                            :}
 |  primary:a DOT:b NEW:c type_arguments_opt:d IDENTIFIER:e type_arguments_opt:f LPAREN:g argument_list_opt:h RPAREN:i class_body_opt:j {:
                                                                                                                                       
                                                                                                                                        TypeNode aa = (new JL5Name(parser, parser.pos(e), e.getIdentifier())).toType();
           RESULT = parser.nf.JL5New(parser.pos(a), a, parser.nf.JL5AmbTypeNode(parser.pos(e, f), ((AmbTypeNode)aa).qual(), ((AmbTypeNode)aa).name(), f), h, j, d); 
                                                                                                                                        
                                                                                                                                        :}
 |  name:a DOT:b NEW:c type_arguments_opt:d IDENTIFIER:e type_arguments_opt:f LPAREN:g argument_list_opt:h RPAREN:i class_body_opt:j {:
                                                                                                                                    
                                                                                                                                     TypeNode aa = (new JL5Name(parser, parser.pos(e), e.getIdentifier())).toType();
           RESULT = parser.nf.JL5New(parser.pos(a), a.toExpr(), parser.nf.JL5AmbTypeNode(parser.pos(e, f), ((AmbTypeNode)aa).qual(), ((AmbTypeNode)aa).name(), f), h, j, d); 
                                                                                                                                     
                                                                                                                                     :};

argument_list_opt ::=
    {:
     RESULT = new TypedList(new LinkedList(), Expr.class, false);  
    :}
 |  argument_list:a {:   RESULT = a;   :};

argument_list ::=
    expression:a {:
                
                 List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; 
                 
                 :}
 |  argument_list:a COMMA expression:b {:
                                      
                                       RESULT = a;
               a.add(b); 
                                       
                                       :};

array_creation_expression ::=
    NEW:n primitive_type:a dim_exprs:b dims_opt:c {:
                                                 
                                                  RESULT = parser.nf.JL5NewArray(parser.pos(n, b), a, b,
                c.intValue(), null); 
                                                  
                                                  :}
 |  NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c {:
                                                          
                                                           RESULT = parser.nf.JL5NewArray(parser.pos(n, b), a, b,
                c.intValue(), null); 
                                                           
                                                           :}
 |  NEW:n primitive_type:a dims:b array_initializer:c {:
                                                     
                                                      RESULT = parser.nf.JL5NewArray(parser.pos(n, c), a, Collections.EMPTY_LIST, b.intValue(), c); 
                                                      
                                                      :}
 |  NEW:n class_or_interface_type:a dims:b array_initializer:c {:
                                                              
                                                               RESULT = parser.nf.JL5NewArray(parser.pos(n, c), a, Collections.EMPTY_LIST,  b.intValue(), c); 
                                                               
                                                               :};

dim_exprs ::=
    dim_expr:a {:
              
               List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; 
               
               :}
 |  dim_exprs:a dim_expr:b {:
                            RESULT = a;
               a.add(b);  
                           :};

dim_expr ::=
    LBRACK:x expression:a RBRACK:y {:
                                  
                                   RESULT = (Expr)a.position(parser.pos(x,y,a)); 
                                   
                                   :};

dims_opt ::=
    {:   RESULT = new Integer(0);   :}
 |  dims:a {:   RESULT = a;   :};

dims ::=
    LBRACK RBRACK {:   RESULT = new Integer(1);   :}
 |  dims:a LBRACK RBRACK {:
                        
                         RESULT = new Integer(a.intValue() + 1); 
                         
                         :};

field_access ::=
    primary:a DOT IDENTIFIER:b {:
                              
                               RESULT = parser.nf.JL5Field(parser.pos(a, b, b), a,
           b.getIdentifier()); 
                               
                               :}
 |  SUPER:n DOT IDENTIFIER:a {:
                            
                             RESULT = parser.nf.JL5Field(parser.pos(a),
           parser.nf.Super(parser.pos(n)),
           a.getIdentifier()); 
                             
                             :}
 |  name:a DOT SUPER:n DOT IDENTIFIER:b {:
                                       
                                        RESULT = parser.nf.JL5Field(parser.pos(b),
           parser.nf.Super(parser.pos(n), a.toType()),
           b.getIdentifier()); 
                                        
                                        :};

method_invocation ::=
    name:a LPAREN argument_list_opt:b RPAREN:d {:
                                              
                                               RESULT = parser.nf.JL5Call(parser.pos(a,d),
                a.prefix == null ? null : a.prefix.toReceiver(),
                a.name, b, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                               
                                               :}
 |  primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                  
                                                                   RESULT = parser.nf.JL5Call(parser.pos(b,d), a,
                b.getIdentifier(), c, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                   
                                                                   :}
 |  SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                
                                                                 RESULT = parser.nf.JL5Call(parser.pos(a,d, b),
                parser.nf.Super(parser.pos(a)),
                b.getIdentifier(), c, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                 
                                                                 :}
 |  name:a DOT SUPER:n DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                           
                                                                            RESULT = parser.nf.JL5Call(parser.pos(b,d),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier(), c, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                            
                                                                            :}
 |  primary:a DOT:b type_arguments:c IDENTIFIER:d LPAREN:e argument_list_opt:f RPAREN:g {:
                                                                                       
                                                                                        RESULT = parser.nf.JL5Call(parser.pos(a, g), a, d.getIdentifier(), f, c); 
                                                                                        
                                                                                        :}
 |  name:a DOT:b type_arguments:c IDENTIFIER:d LPAREN:e argument_list_opt:f RPAREN:g {:
                                                                                    
                                                                                     RESULT = parser.nf.JL5Call(parser.pos(a, g), a.toReceiver(), d.getIdentifier(), f, c); 
                                                                                     
                                                                                     :}
 |  SUPER:a DOT:b type_arguments:c IDENTIFIER:d LPAREN:e argument_list_opt:f RPAREN:g {:
                                                                                     
                                                                                      RESULT = parser.nf.JL5Call(parser.pos(a, g, d), parser.nf.Super(parser.pos(a)), d.getIdentifier(), f, c); 
                                                                                      
                                                                                      :}
 |  name:a DOT:b SUPER:c DOT:d type_arguments:e IDENTIFIER:f LPAREN:g argument_list_opt:h RPAREN:i {:
                                                                                                  
                                                                                                   RESULT = parser.nf.JL5Call(parser.pos(f, i), parser.nf.Super(parser.pos(c), a.toType()), f.getIdentifier(), h, e); 
                                                                                                   
                                                                                                   :};

array_access ::=
    name:a LBRACK expression:b RBRACK:d {:
                                       
                                        RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a.toExpr(), b); 
                                        
                                        :}
 |  primary_no_new_array:a LBRACK expression:b RBRACK:d {:
                                                       
                                                        RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, b); 
                                                        
                                                        :}
 |  array_creation_init:a LBRACK:b expression:c RBRACK:d {:
                                                        
                                                         RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, c); 
                                                         
                                                         :};

postfix_expression ::=
    primary:a {:   RESULT = a;   :}
 |  name:a {:   RESULT = a.toExpr();   :}
 |  postincrement_expression:a {:   RESULT = a;   :}
 |  postdecrement_expression:a {:   RESULT = a;   :};

postincrement_expression ::=
    postfix_expression:a PLUSPLUS:b {:
                                   
                                    RESULT = parser.nf.Unary(parser.pos(a,b), Unary.POST_INC, a); 
                                    
                                    :};

postdecrement_expression ::=
    postfix_expression:a MINUSMINUS:b {:
                                     
                                      RESULT = parser.nf.Unary(parser.pos(a,b), Unary.POST_DEC, a); 
                                      
                                      :};

unary_expression ::=
    preincrement_expression:a {:   RESULT = a;   :}
 |  predecrement_expression:a {:   RESULT = a;   :}
 |  PLUS:b unary_expression:a {:
                             
                              RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.POS, a); 
                              
                              :}
 |  MINUS:b unary_expression:a {:
                              
                               RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NEG, a); 
                               
                               :}
 |  MINUS:b boundary_literal:a {:
                              
                               RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NEG, a); 
                               
                               :}
 |  unary_expression_not_plus_minus:a {:   RESULT = a;   :};

preincrement_expression ::=
    PLUSPLUS:b unary_expression:a {:
                                 
                                  RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.PRE_INC, a); 
                                  
                                  :};

predecrement_expression ::=
    MINUSMINUS:b unary_expression:a {:
                                   
                                    RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.PRE_DEC, a); 
                                    
                                    :};

unary_expression_not_plus_minus ::=
    postfix_expression:a {:   RESULT = a;   :}
 |  COMP:b unary_expression:a {:
                             
                              RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.BIT_NOT, a); 
                              
                              :}
 |  NOT:b unary_expression:a {:
                            
                             RESULT = parser.nf.Unary(parser.pos(b,a,a), Unary.NOT, a); 
                             
                             :}
 |  cast_expression:a {:   RESULT = a;   :};

cast_expression ::=
    LPAREN:a primitive_type:b dims_opt:c RPAREN:d unary_expression:e {:
                                                                    
                                                                     RESULT = parser.nf.JL5Cast(parser.pos(a, e, b), parser.array(b, c.intValue()), e); 
                                                                     
                                                                     :}
 |  LPAREN:a name:b RPAREN:c unary_expression_not_plus_minus:d {:
                                                              
                                                               RESULT = parser.nf.JL5Cast(parser.pos(a, d, b), parser.exprToType(b.toExpr()), d); 
                                                               
                                                               :}
 |  LPAREN:a name:b dims:c RPAREN:d unary_expression_not_plus_minus:e {:
                                                                     
                                                                      RESULT = parser.nf.JL5Cast(parser.pos(a, e, b), parser.array(b.toType(), c.intValue()), e); 
                                                                      
                                                                      :}
 |  LPAREN:a name:b LT:c type_argument_list_1:d dims_opt:e RPAREN:f unary_expression_not_plus_minus:g {:
                                                                                                     
                                                                                                      AmbTypeNode aa = (AmbTypeNode)b.toType();
           RESULT = parser.nf.JL5Cast(parser.pos(a, g, b), parser.array(parser.nf.JL5AmbTypeNode(parser.pos(b, d), aa.qual(), aa.name(), d), e.intValue()), g); 
                                                                                                      
                                                                                                      :}
 |  LPAREN:a name:b LT:c type_argument_list_1:d DOT:e class_or_interface_type:f dims_opt:g RPAREN:h unary_expression_not_plus_minus:i {:
                                                                                                                                     
                                                                                                                                      AmbTypeNode aa = (AmbTypeNode)b.toType();
           AmbTypeNode bb = (AmbTypeNode)f;
           RESULT = parser.nf.JL5Cast(parser.pos(a, i, b), parser.array(parser.nf.AmbTypeNode(parser.pos(b, f), parser.nf.JL5AmbQualifierNode(parser.pos(b, d), aa.qual(), aa.name(), d), bb.name()), g.intValue()), i); 
                                                                                                                                      
                                                                                                                                      :};

multiplicative_expression ::=
    unary_expression:a {:   RESULT = a;   :}
 |  multiplicative_expression:a MULT unary_expression:b {:
                                                       
                                                        RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.MUL, b); 
                                                        
                                                        :}
 |  multiplicative_expression:a DIV unary_expression:b {:
                                                      
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.DIV, b); 
                                                       
                                                       :}
 |  multiplicative_expression:a MOD unary_expression:b {:
                                                      
                                                       RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.MOD, b); 
                                                       
                                                       :};

additive_expression ::=
    multiplicative_expression:a {:   RESULT = a;   :}
 |  additive_expression:a PLUS multiplicative_expression:b {:
                                                          
                                                           RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.ADD, b); 
                                                           
                                                           :}
 |  additive_expression:a MINUS multiplicative_expression:b {:
                                                           
                                                            RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SUB, b); 
                                                            
                                                            :};

shift_expression ::=
    additive_expression:a {:   RESULT = a;   :}
 |  shift_expression:a LSHIFT additive_expression:b {:
                                                   
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SHL, b); 
                                                    
                                                    :}
 |  shift_expression:a RSHIFT additive_expression:b {:
                                                   
                                                    RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SHR, b); 
                                                    
                                                    :}
 |  shift_expression:a URSHIFT additive_expression:b {:
                                                    
                                                     RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.USHR, b); 
                                                     
                                                     :};

relational_expression ::=
    shift_expression:a {:   RESULT = a;   :}
 |  relational_expression:a LT:b shift_expression:c {:
                                                   
                                                    RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LT, c); 
                                                    
                                                    :}
 |  relational_expression:a GT:b shift_expression:c {:
                                                   
                                                    RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GT, c); 
                                                    
                                                    :}
 |  relational_expression:a LTEQ:b shift_expression:c {:
                                                     
                                                      RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LE, c); 
                                                      
                                                      :}
 |  relational_expression:a GTEQ:b shift_expression:c {:
                                                     
                                                      RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GE, c); 
                                                      
                                                      :};

equality_expression ::=
    instanceof_expression:a {:   RESULT = a;   :}
 |  equality_expression:a EQEQ:b instanceof_expression:c {:
                                                        
                                                         RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.EQ, c); 
                                                         
                                                         :}
 |  equality_expression:a NOTEQ:b instanceof_expression:c {:
                                                         
                                                          RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.NE, c); 
                                                          
                                                          :};

and_expression ::=
    equality_expression:a {:   RESULT = a;   :}
 |  and_expression:a AND equality_expression:b {:
                                              
                                               RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_AND, b); 
                                               
                                               :};

exclusive_or_expression ::=
    and_expression:a {:   RESULT = a;   :}
 |  exclusive_or_expression:a XOR and_expression:b {:
                                                  
                                                   RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_XOR, b); 
                                                   
                                                   :};

inclusive_or_expression ::=
    exclusive_or_expression:a {:   RESULT = a;   :}
 |  inclusive_or_expression:a OR exclusive_or_expression:b {:
                                                          
                                                           RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_OR, b); 
                                                           
                                                           :};

conditional_and_expression ::=
    inclusive_or_expression:a {:   RESULT = a;   :}
 |  conditional_and_expression:a ANDAND inclusive_or_expression:b {:
                                                                 
                                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.COND_AND, b); 
                                                                  
                                                                  :};

conditional_or_expression ::=
    conditional_and_expression:a {:   RESULT = a;   :}
 |  conditional_or_expression:a OROR conditional_and_expression:b {:
                                                                 
                                                                  RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.COND_OR, b); 
                                                                  
                                                                  :};

conditional_expression ::=
    conditional_or_expression:a {:   RESULT = a;   :}
 |  conditional_or_expression:a QUESTION expression:b COLON conditional_expression:c {:
                                                                                    
                                                                                     RESULT = parser.nf.JL5Conditional(parser.pos(a, c), a, b, c); 
                                                                                     
                                                                                     :};

assignment_expression ::=
    conditional_expression:a {:   RESULT = a;   :}
 |  assignment:a {:   RESULT = a;   :};

assignment ::=
    left_hand_side:a assignment_operator:b assignment_expression:c {:
                                                                  
                                                                   RESULT = parser.nf.Assign(parser.pos(a, c), a, b, c); 
                                                                   
                                                                   :};

left_hand_side ::=
    name:a {:   RESULT = a.toExpr();   :}
 |  field_access:a {:   RESULT = a;   :}
 |  array_access:a {:   RESULT = a;   :};

assignment_operator ::=
    EQ {:   RESULT = Assign.ASSIGN;   :}
 |  MULTEQ {:   RESULT = Assign.MUL_ASSIGN;   :}
 |  DIVEQ {:   RESULT = Assign.DIV_ASSIGN;   :}
 |  MODEQ {:   RESULT = Assign.MOD_ASSIGN;   :}
 |  PLUSEQ {:   RESULT = Assign.ADD_ASSIGN;   :}
 |  MINUSEQ {:   RESULT = Assign.SUB_ASSIGN;   :}
 |  LSHIFTEQ {:   RESULT = Assign.SHL_ASSIGN;   :}
 |  RSHIFTEQ {:   RESULT = Assign.SHR_ASSIGN;   :}
 |  URSHIFTEQ {:   RESULT = Assign.USHR_ASSIGN;   :}
 |  ANDEQ {:   RESULT = Assign.BIT_AND_ASSIGN;   :}
 |  XOREQ {:   RESULT = Assign.BIT_XOR_ASSIGN;   :}
 |  OREQ {:   RESULT = Assign.BIT_OR_ASSIGN;   :};

expression_opt ::=
    {:   RESULT = null;   :}
 |  expression:a {:   RESULT = a;   :};

expression ::=
    assignment_expression:a {:   RESULT = a;   :};

constant_expression ::=
    expression:a {:   RESULT = a;   :};

type_variable ::=
    IDENTIFIER:a {:
                
                 RESULT = new Name(parser, parser.pos(a), a.getIdentifier()); 
                 
                 :};

class_or_interface ::=
    name:a {:   RESULT = a.toType();   :}
 |  class_or_interface:a LT:b type_argument_list_1:c DOT:d name:e {:
                                                                 
                                                                  RESULT = parser.nf.AmbTypeNode(parser.pos(a, e), parser.nf.JL5AmbQualifierNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c), e.toString()); 
                                                                  
                                                                  :};

type_arguments_opt ::=
    type_arguments:a {:   RESULT = a;   :}
 |  {:
   
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    
    :};

type_arguments ::=
    LT type_argument_list_1:a {:   RESULT = a;   :};

wildcard ::=
    QUESTION {:   RESULT = parser.toBoundedType(null);   :}
 |  QUESTION EXTENDS reference_type:a {:
                                     
                                      RESULT = parser.toExtendsType(a); 
                                      
                                      :}
 |  QUESTION SUPER reference_type:a {:
                                   
                                    RESULT = parser.toSuperType(a); 
                                    
                                    :};

wildcard_1 ::=
    QUESTION GT {:   RESULT = parser.toBoundedType(null);   :}
 |  QUESTION EXTENDS reference_type_1:a {:
                                       
                                        RESULT = parser.toExtendsType(a); 
                                        
                                        :}
 |  QUESTION SUPER reference_type_1:a {:
                                     
                                      RESULT = parser.toSuperType(a); 
                                      
                                      :};

wildcard_2 ::=
    QUESTION RSHIFT {:   RESULT = parser.toBoundedType(null);   :}
 |  QUESTION EXTENDS reference_type_2:a {:
                                       
                                        RESULT = parser.toExtendsType(a); 
                                        
                                        :}
 |  QUESTION SUPER reference_type_2:a {:
                                     
                                      RESULT = parser.toSuperType(a); 
                                      
                                      :};

wildcard_3 ::=
    QUESTION URSHIFT {:   RESULT = parser.toBoundedType(null);   :}
 |  QUESTION EXTENDS reference_type_3:a {:
                                       
                                        RESULT = parser.toExtendsType(a); 
                                        
                                        :}
 |  QUESTION SUPER reference_type_3:a {:
                                     
                                      RESULT = parser.toSuperType(a); 
                                      
                                      :};

reference_type_1 ::=
    reference_type:a GT {:   RESULT = a;   :}
 |  class_or_interface:a LT:b type_argument_list_2:c {:
                                                    
                                                     RESULT = parser.nf.JL5AmbTypeNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c); 
                                                     
                                                     :};

reference_type_2 ::=
    reference_type:a RSHIFT {:   RESULT = a;   :}
 |  class_or_interface:a LT:b type_argument_list_3:c {:
                                                    
                                                     RESULT = parser.nf.JL5AmbTypeNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c); 
                                                     
                                                     :};

reference_type_3 ::=
    reference_type:a URSHIFT {:   RESULT = a;   :};

type_argument_list ::=
    type_argument:a {:
                   
                    List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                    
                    :}
 |  type_argument_list:a COMMA type_argument:b {:
                                              
                                               a.add(b);
           RESULT = a; 
                                               
                                               :};

type_argument_list_1 ::=
    type_argument_1:a {:
                     
                      List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                      
                      :}
 |  type_argument_list:a COMMA type_argument_1:b {:
                                                
                                                 a.add(b);
           RESULT = a; 
                                                 
                                                 :};

type_argument_list_2 ::=
    type_argument_2:a {:
                     
                      List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                      
                      :}
 |  type_argument_list:a COMMA type_argument_2:b {:
                                                
                                                 a.add(b);
           RESULT = a; 
                                                 
                                                 :};

type_argument_list_3 ::=
    type_argument_3:a {:
                     
                      List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                      
                      :}
 |  type_argument_list:a COMMA type_argument_3:b {:
                                                
                                                 a.add(b);
           RESULT = a; 
                                                 
                                                 :};

type_argument ::=
    reference_type:a {:   RESULT = a;   :}
 |  wildcard:a {:   RESULT = a;   :};

type_argument_1 ::=
    reference_type_1:a {:   RESULT = a;   :}
 |  wildcard_1:a {:   RESULT = a;   :};

type_argument_2 ::=
    reference_type_2:a {:   RESULT = a;   :}
 |  wildcard_2:a {:   RESULT = a;   :};

type_argument_3 ::=
    reference_type_3:a {:   RESULT = a;   :}
 |  wildcard_3:a {:   RESULT = a;   :};

static_single_type_import_declaration ::=
    IMPORT:a STATIC:b name:c SEMICOLON:d {:
                                        
                                         RESULT = parser.nf.JL5Import(parser.pos(a, d), JL5Import.MEMBER, c.toString()); 
                                         
                                         :};

static_type_import_on_demand_declaration ::=
    IMPORT:a STATIC:b name:c DOT MULT SEMICOLON:d {:
                                                 
                                                  RESULT = parser.nf.JL5Import(parser.pos(a, d), JL5Import.ALL_MEMBERS, c.toString()); 
                                                  
                                                  :};

class_body_opt ::=
    {:   RESULT = null;   :}
 |  class_body:a {:   RESULT = a;   :};

enum_declaration ::=
    modifiers_or_annotations_opt:a ENUM:b IDENTIFIER:c interfaces_opt:d enum_body:e {:
                                                                                   
                                                                                    RESULT = parser.nf.JL5ClassDecl(parser.pos(b, e), a.classicFlags(JL5Flags.setEnumModifier(a.classicFlags())), c.getIdentifier(), parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Enum()), d, e, new TypedList(new LinkedList(), TypeNode.class, false)); 
                                                                                    
                                                                                    :};

enum_body ::=
    LBRACE:n enum_constants_opt:a enum_body_declarations_opt:b RBRACE:c {:
                                                                       
                                                                        a.addAll(b);
               RESULT = parser.nf.JL5ClassBody(parser.pos(n, c), a); 
                                                                        
                                                                        :};

enum_constants_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    
    :}
 |  enum_constants:a {:   RESULT = a;   :};

enum_constants ::=
    enum_constant:a {:
                   
                    List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                    
                    :}
 |  enum_constants:a COMMA enum_constant:b {:
                                          
                                           List l = a;
           a.add(b);
           RESULT = l; 
                                           
                                           :};

enum_constant ::=
    modifiers_or_annotations_opt:d IDENTIFIER:a enum_arguments_opt:b {:
                                                                    
                                                                     RESULT = parser.nf.EnumConstantDecl(parser.pos(a), d, a.getIdentifier(), b); 
                                                                     
                                                                     :}
 |  modifiers_or_annotations_opt:d IDENTIFIER:a enum_arguments_opt:b class_body:c {:
                                                                                 
                                                                                  RESULT = parser.nf.EnumConstantDecl(parser.pos(a), d, a.getIdentifier(), b, c); 
                                                                                  
                                                                                  :};

enum_arguments_opt ::=
    {:
     RESULT = new TypedList(new LinkedList(), Expr.class, false);  
    :}
 |  LPAREN argument_list_opt:a RPAREN {:   RESULT = a;   :};

enum_body_declarations_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    
    :}
 |  SEMICOLON class_body_declarations_opt:a {:   RESULT = a;   :};

method_declarator ::=
    IDENTIFIER:a LPAREN:b formal_parameter_list_opt:c RPAREN:d {:
                                                              
                                                               RESULT = new MethodDeclarator(parser.pos(a, d), a.getIdentifier(), c); 
                                                               
                                                               :}
 |  method_declarator:a LBRACK:b RBRACK:c {:
                                         
                                          RESULT = new MethodDeclarator(parser.pos(a, c), a.name(), a.formals(), new Integer(1)); 
                                          
                                          :};

constructor_declarator ::=
    simple_name:a LPAREN:b formal_parameter_list_opt:c RPAREN:d {:
                                                               
                                                                RESULT = new ConstructorDeclarator(parser.pos(a, d), a.toString(), c); 
                                                                
                                                                :};

foreach_statement ::=
    FOR:a LPAREN:b type:c variable_declarator_id:d COLON:e expression:f RPAREN:g statement:h {:
                                                                                            
                                                                                             RESULT = parser.nf.ExtendedFor(parser.pos(a, h), parser.variableDeclarators(c, d, null), f, h); 
                                                                                             
                                                                                             :}
 |  FOR:a LPAREN:b modifiers_or_annotations:c type:d variable_declarator_id:e COLON:f expression:g RPAREN:h statement:i {:
                                                                                                                       
                                                                                                                        RESULT = parser.nf.ExtendedFor(parser.pos(a, i), parser.variableDeclarators(d, e, c), g, i); 
                                                                                                                        
                                                                                                                        :};

foreach_statement_no_short_if ::=
    FOR:a LPAREN:b type:c variable_declarator_id:d COLON:e expression:f RPAREN:g statement_no_short_if:h {:
                                                                                                        
                                                                                                         RESULT = parser.nf.ExtendedFor(parser.pos(a, h), parser.variableDeclarators(c, d, null), f, h); 
                                                                                                         
                                                                                                         :}
 |  FOR:a LPAREN:b modifiers_or_annotations:c type:d variable_declarator_id:e COLON:f expression:g RPAREN:h statement_no_short_if:i {:
                                                                                                                                   
                                                                                                                                    RESULT = parser.nf.ExtendedFor(parser.pos(a, i), parser.variableDeclarators(d, e, c), g, i); 
                                                                                                                                    
                                                                                                                                    :};

array_creation_init ::=
    NEW:a primitive_type:b dims:c array_initializer:d {:
                                                     
                                                      RESULT = parser.nf.JL5NewArray(parser.pos(a, d), b, Collections.EMPTY_LIST, c.intValue(), d); 
                                                      
                                                      :}
 |  NEW:a class_or_interface_type:b dims:c array_initializer:d {:
                                                              
                                                               RESULT = parser.nf.JL5NewArray(parser.pos(a, d), b,
                Collections.EMPTY_LIST, c.intValue(), d); 
                                                               
                                                               :};

instanceof_expression ::=
    relational_expression:a {:   RESULT = a;   :}
 |  instanceof_expression:a INSTANCEOF:b reference_type:c {:
                                                         
                                                          RESULT = parser.nf.JL5Instanceof(parser.pos(a, c), a, c); 
                                                          
                                                          :};

type_parameters_opt ::=
    type_parameters:a {:   RESULT = a;   :}
 |  {:
   
    RESULT = new TypedList(new LinkedList(), TypeNode.class, false); 
    
    :};

type_parameters ::=
    LT type_parameter_list_1:a {:   RESULT = a;   :};

type_parameter_list ::=
    type_parameter_list:a COMMA type_parameter:b {:
                                                
                                                 a.add(b);
           RESULT = a; 
                                                 
                                                 :}
 |  type_parameter:a {:
                    
                     List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                     
                     :};

type_parameter_list_1 ::=
    type_parameter_1:a {:
                      
                       List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                       
                       :}
 |  type_parameter_list:a COMMA type_parameter_1:b {:
                                                  
                                                   a.add(b);
           RESULT = a; 
                                                   
                                                   :};

type_parameter ::=
    type_variable:a type_bound_opt:b {:
                                    
                                     RESULT = parser.toParamType(parser.pos(a, b), a.toString(), b); 
                                     
                                     :};

type_parameter_1 ::=
    type_variable:a GT {:
                      
                       RESULT = parser.toParamType(parser.pos(a), a.toString(), null); 
                       
                       :}
 |  type_variable:a type_bound_1:b {:
                                  
                                   RESULT = parser.toParamType(parser.pos(a, b), a.toString(), b); 
                                   
                                   :};

type_bound_opt ::=
    type_bound:a {:   RESULT = a;   :}
 |  {:   RESULT = null;   :};

type_bound ::=
    EXTENDS reference_type:a additional_bound_list_opt:b {:
                                                        
                                                         if (b == null) {
                List l = new TypedList(new LinkedList(), TypeNode.class, false);
                l.add(a);
                RESULT = l;
           } 
           else {
                b.add(0, a);
                RESULT = b;
           }
                                                         
                                                         :};

type_bound_1 ::=
    EXTENDS reference_type_1:a {:
                              
                               List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                               
                               :}
 |  EXTENDS reference_type:a additional_bound_list_1:b {:
                                                      
                                                       b.add(0, a);
           RESULT = b; 
                                                       
                                                       :};

additional_bound_list_opt ::=
    additional_bound_list:a {:   RESULT = a;   :}
 |  {:   RESULT = null;   :};

additional_bound_list ::=
    additional_bound:a additional_bound_list:b {:
                                              
                                               b.add(0, a);
           RESULT = b; 
                                               
                                               :}
 |  additional_bound:a {:
                      
                       List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                       
                       :};

additional_bound_list_1 ::=
    additional_bound:a additional_bound_list_1:b {:
                                                
                                                 b.add(0, a);
           RESULT = b; 
                                                 
                                                 :}
 |  additional_bound_1:a {:
                        
                         List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; 
                         
                         :};

additional_bound ::=
    AND interface_type:a {:   RESULT = a;   :};

additional_bound_1 ::=
    AND reference_type_1:a {:   RESULT = a;   :};

postfix_expression_nn ::=
    primary:a {:   RESULT = a;   :}
 |  postincrement_expression:a {:   RESULT = a;   :}
 |  postdecrement_expression:a {:   RESULT = a;   :};

unary_expression_nn ::=
    preincrement_expression:a {:   RESULT = a;   :}
 |  predecrement_expression:a {:   RESULT = a;   :}
 |  PLUS:a unary_expression:b {:
                             
                              RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.POS, b); 
                              
                              :}
 |  MINUS:a unary_expression:b {:
                              
                               RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.NEG, b); 
                               
                               :}
 |  MINUS:a boundary_literal:b {:
                              
                               RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.NEG, b); 
                               
                               :}
 |  unary_expression_not_plus_minus_nn:a {:   RESULT = a;   :};

unary_expression_not_plus_minus_nn ::=
    postfix_expression_nn:a {:   RESULT = a;   :}
 |  COMP:a unary_expression:b {:
                             
                              RESULT = parser.nf.Unary(parser.pos(a,b,b), Unary.BIT_NOT, b); 
                              
                              :}
 |  NOT:a unary_expression:b {:
                            
                             RESULT = parser.nf.Unary(parser.pos(a,b,b), Unary.NOT, b); 
                             
                             :}
 |  cast_expression:a {:   RESULT = a;   :};

multiplicative_expression_nn ::=
    unary_expression_nn:a {:   RESULT = a;   :}
 |  name:a MULT:b unary_expression:c {:
                                    
                                     RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.MUL, c); 
                                     
                                     :}
 |  multiplicative_expression_nn:a MULT:b unary_expression:c {:
                                                            
                                                             RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.MUL, c); 
                                                             
                                                             :}
 |  name:a DIV:b unary_expression:c {:
                                   
                                    RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.DIV, c); 
                                    
                                    :}
 |  multiplicative_expression_nn:a DIV:b unary_expression:c {:
                                                           
                                                            RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.DIV, c); 
                                                            
                                                            :}
 |  name:a MOD:b unary_expression:c {:
                                   
                                    RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.MOD, c); 
                                    
                                    :}
 |  multiplicative_expression_nn:a MOD:b unary_expression:c {:
                                                           
                                                            RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.MOD, c); 
                                                            
                                                            :};

additive_expression_nn ::=
    multiplicative_expression_nn:a {:   RESULT = a;   :}
 |  name:a PLUS:b multiplicative_expression:c {:
                                             
                                              RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.ADD, c); 
                                              
                                              :}
 |  additive_expression_nn:a PLUS:b multiplicative_expression:c {:
                                                               
                                                                RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.ADD, c); 
                                                                
                                                                :}
 |  name:a MINUS:b multiplicative_expression:c {:
                                              
                                               RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SUB, c); 
                                               
                                               :}
 |  additive_expression_nn:a MINUS:b multiplicative_expression:c {:
                                                                
                                                                 RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SUB, c); 
                                                                 
                                                                 :};

shift_expression_nn ::=
    additive_expression_nn:a {:   RESULT = a;   :}
 |  name:a LSHIFT:b additive_expression:c {:
                                         
                                          RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SHL, c); 
                                          
                                          :}
 |  shift_expression_nn:a LSHIFT:b additive_expression:c {:
                                                        
                                                         RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SHL, c); 
                                                         
                                                         :}
 |  name:a RSHIFT:b additive_expression:c {:
                                         
                                          RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SHR, c); 
                                          
                                          :}
 |  shift_expression_nn:a RSHIFT:b additive_expression:c {:
                                                        
                                                         RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SHR, c); 
                                                         
                                                         :}
 |  name:a URSHIFT:b additive_expression:c {:
                                          
                                           RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.USHR, c); 
                                           
                                           :}
 |  shift_expression_nn:a URSHIFT:b additive_expression:c {:
                                                         
                                                          RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.USHR, c); 
                                                          
                                                          :};

relational_expression_nn ::=
    shift_expression_nn:a {:   RESULT = a;   :}
 |  name:a LT:b shift_expression:c {:
                                  
                                   RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.LT, c); 
                                   
                                   :}
 |  shift_expression_nn:a LT:b shift_expression:c {:
                                                 
                                                  RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LT, c); 
                                                  
                                                  :}
 |  name:a GT:b shift_expression:c {:
                                  
                                   RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GT, c); 
                                   
                                   :}
 |  shift_expression_nn:a GT:b shift_expression:c {:
                                                 
                                                  RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GT, c); 
                                                  
                                                  :}
 |  name:a LTEQ:b shift_expression:c {:
                                    
                                     RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.LE, c); 
                                     
                                     :}
 |  relational_expression_nn:a LTEQ:b shift_expression:c {:
                                                        
                                                         RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LE, c); 
                                                         
                                                         :}
 |  name:a GTEQ:b shift_expression:c {:
                                    
                                     RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GE, c); 
                                     
                                     :}
 |  relational_expression_nn:a GTEQ:b shift_expression:c {:
                                                        
                                                         RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GE, c); 
                                                         
                                                         :};

instanceof_expression_nn ::=
    relational_expression_nn:a {:   RESULT = a;   :}
 |  name:a INSTANCEOF:b reference_type:c {:
                                        
                                         RESULT = parser.nf.JL5Instanceof(parser.pos(a, c), a.toExpr(), c); 
                                         
                                         :}
 |  instanceof_expression_nn:a INSTANCEOF:b reference_type:c {:
                                                            
                                                             RESULT = parser.nf.JL5Instanceof(parser.pos(a, c), a, c); 
                                                             
                                                             :};

equality_expression_nn ::=
    instanceof_expression_nn:a {:   RESULT = a;   :}
 |  name:a EQEQ:b instanceof_expression:c {:
                                         
                                          RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.EQ, c); 
                                          
                                          :}
 |  equality_expression_nn:a EQEQ:b instanceof_expression:c {:
                                                           
                                                            RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.EQ, c); 
                                                            
                                                            :}
 |  name:a NOTEQ:b instanceof_expression:c {:
                                          
                                           RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.NE, c); 
                                           
                                           :}
 |  equality_expression_nn:a NOTEQ:b instanceof_expression:c {:
                                                            
                                                             RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.NE, c); 
                                                             
                                                             :};

and_expression_nn ::=
    equality_expression_nn:a {:   RESULT = a;   :}
 |  name:a AND:b equality_expression:c {:
                                      
                                       RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_AND, c); 
                                       
                                       :}
 |  and_expression_nn:a AND:b equality_expression:c {:
                                                   
                                                    RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_AND, c); 
                                                    
                                                    :};

exclusive_or_expression_nn ::=
    and_expression_nn:a {:   RESULT = a;   :}
 |  name:a XOR:b and_expression:c {:
                                 
                                  RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_XOR, c); 
                                  
                                  :}
 |  exclusive_or_expression_nn:a XOR:b and_expression:c {:
                                                       
                                                        RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_XOR, c); 
                                                        
                                                        :};

inclusive_or_expression_nn ::=
    exclusive_or_expression_nn:a {:   RESULT = a;   :}
 |  name:a OR:b exclusive_or_expression:c {:
                                         
                                          RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_OR, c); 
                                          
                                          :}
 |  inclusive_or_expression_nn:a OR:b exclusive_or_expression:c {:
                                                               
                                                                RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_OR, c); 
                                                                
                                                                :};

conditional_and_expression_nn ::=
    inclusive_or_expression_nn:a {:   RESULT = a;   :}
 |  name:a ANDAND:b inclusive_or_expression:c {:
                                             
                                              RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.COND_AND, c); 
                                              
                                              :}
 |  conditional_and_expression_nn:a ANDAND:b inclusive_or_expression:c {:
                                                                      
                                                                       RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.COND_AND, c); 
                                                                       
                                                                       :};

conditional_or_expression_nn ::=
    conditional_and_expression_nn:a {:   RESULT = a;   :}
 |  name:a OROR:b conditional_and_expression:c {:
                                              
                                               RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.COND_OR, c); 
                                               
                                               :}
 |  conditional_or_expression_nn:a OROR:b conditional_and_expression:c {:
                                                                      
                                                                       RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.COND_OR, c); 
                                                                       
                                                                       :};

conditional_expression_nn ::=
    conditional_or_expression_nn:a {:   RESULT = a;   :}
 |  name:a QUESTION:b expression:c COLON:d conditional_expression:e {:
                                                                   
                                                                    RESULT = parser.nf.JL5Conditional(parser.pos(a, e), a.toExpr(), c, e); 
                                                                    
                                                                    :}
 |  conditional_or_expression_nn:a QUESTION:b expression:c COLON:d conditional_expression:e {:
                                                                                           
                                                                                            RESULT = parser.nf.JL5Conditional(parser.pos(a, e), a, c, e); 
                                                                                            
                                                                                            :};

assignment_expression_nn ::=
    conditional_expression_nn:a {:   RESULT = a;   :}
 |  assignment:a {:   RESULT = a;   :};

expression_nn ::=
    assignment_expression_nn:a {:   RESULT = a;   :};

element_values ::=
    element_value:a {:
                   
                    List l = new TypedList(new LinkedList(), Expr.class, false);
           l.add(a);
           RESULT = l;
        
                    
                    :}
 |  element_values:a COMMA element_value:b {:
                                          
                                           a.add(b);
           RESULT = a;
        
                                           
                                           :};

element_value_array_initializer ::=
    LBRACE:n element_values:a COMMA RBRACE:d {:
                                            
                                             RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); 
                                             
                                             :}
 |  LBRACE:n element_values:a RBRACE:d {:
                                      
                                       RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); 
                                       
                                       :}
 |  LBRACE:n COMMA RBRACE:d {:
                           
                            RESULT = parser.nf.ArrayInit(parser.pos(n, d)); 
                            
                            :}
 |  LBRACE:n RBRACE:d {:
                     
                      RESULT = parser.nf.ArrayInit(parser.pos(n, d)); 
                      
                      :};

element_value ::=
    element_value_array_initializer:a {:   RESULT = a;   :}
 |  conditional_expression:a {:   RESULT = a;   :}
 |  annotation:a {:   RESULT = a;   :};

modifiers_or_annotations_opt ::=
    {:
   
    FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.NONE);
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = fl; 
    
    :}
 |  modifiers_or_annotations:a {:   RESULT = a;   :};

modifiers_or_annotations ::=
    modifier_or_annotation:a {:
                            
                             FlagAnnotations fl = new FlagAnnotations();
           if (parser.isClassicFlag(a)){
               if (fl.classicFlags().intersects((Flags)a)) parser.die(parser.position());
               fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
               RESULT = fl.classicFlags(fl.classicFlags().set((Flags)a));
           }
           else {
               fl.classicFlags(Flags.NONE);
               RESULT = fl.addAnnotation(a);
           }
        
                             
                             :}
 |  modifiers_or_annotations:a modifier_or_annotation:b {:
                                                       
                                                        if (parser.isClassicFlag(b)){
               if (a.classicFlags().intersects((Flags)b)) parser.die(parser.position());
               RESULT = a.classicFlags(a.classicFlags().set((Flags)b));
           }
           else {
               RESULT = a.addAnnotation(b);
           }
        
                                                        
                                                        :};

modifier_or_annotation ::=
    modifier:a {:   RESULT = a;   :}
 |  annotation:a {:   RESULT = a;   :};

annotation ::=
    normal_annotation:a {:   RESULT = a;   :}
 |  marker_annotation:a {:   RESULT = a;   :}
 |  single_element_annotation:a {:   RESULT = a;   :};

marker_annotation ::=
    AT:a simple_name:b {:
                      
                       RESULT = parser.nf.MarkerAnnotationElem(parser.pos(b), b.toType()); 
                       
                       :};

single_element_annotation ::=
    AT:a simple_name:b LPAREN element_value:c RPAREN {:
                                                    
                                                     RESULT = parser.nf.SingleElementAnnotationElem(parser.pos(b), b.toType(), c); 
                                                     
                                                     :};

normal_annotation ::=
    AT:a simple_name:b LPAREN element_value_pairs_opt:c RPAREN {:
                                                              
                                                              RESULT = parser.nf.NormalAnnotationElem(parser.pos(b), b.toType(), c); 
                                                               
                                                               :};

element_value_pairs_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ElementValuePair.class, false); 
    
    :}
 |  element_value_pairs:a {:   RESULT = a;   :};

element_value_pairs ::=
    element_value_pair:a {:
                        
                         List l = new TypedList(new LinkedList(), ElementValuePair.class, false);
           l.add(a);
           RESULT = l;
        
                         
                         :}
 |  element_value_pairs:a COMMA element_value_pair:b {:
                                                    
                                                     a.add(b);
           RESULT = a; 
                                                     
                                                     :};

element_value_pair ::=
    IDENTIFIER:a EQ element_value:b {:
                                   
                                    RESULT = parser.nf.ElementValuePair(parser.pos(a,b), a.getIdentifier(), b); 
                                    
                                    :};

annotation_body ::=
    LBRACE:n annotation_type_element_declarations_opt:a RBRACE:d {:
                                                                
                                                                 RESULT = parser.nf.JL5ClassBody(parser.pos(n,d), a); 
                                                                 
                                                                 :};

annotation_type_element_declarations_opt ::=
    {:
   
    RESULT = new TypedList(new LinkedList(), ClassMember.class, false); 
    
    :}
 |  annotation_type_element_declarations:a {:   RESULT = a;   :};

annotation_type_element_declarations ::=
    annotation_type_element_declaration:a {:   RESULT = a;   :}
 |  annotation_type_element_declarations:a annotation_type_element_declaration:b {:
                                                                                
                                                                                 RESULT = a;
           a.addAll(b); 
                                                                                 
                                                                                 :};

annotation_type_element_declaration ::=
    modifiers_or_annotations_opt:a type:b IDENTIFIER:c LPAREN RPAREN default_value_opt:d SEMICOLON {:
                                                                                                  
                                                                                                   List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.AnnotationElemDecl(parser.pos(b,d), a, parser.array(b, (new Integer(0)).intValue()), c.getIdentifier(), d));
           RESULT = l; 
                                                                                                   
                                                                                                   :}
 |  constant_declaration:a {:   RESULT = a;   :}
 |  class_declaration:a {:
                       
                        List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                        
                        :}
 |  interface_declaration:a {:
                           
                            List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                            
                            :}
 |  enum_declaration:a {:
                      
                       List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; 
                       
                       :} SEMICOLON {:
                                   
                                    RESULT = Collections.EMPTY_LIST; 
                                    
                                    :};

default_value_opt ::=
    {:   RESULT = null;   :}
 |  DEFAULT element_value:a {:   RESULT = a;   :};

fn_method_declaration ::=
    fn_method_header:a fn_method_body:b {:
                                        ESJMethodDecl mainMtdDecl = (ESJMethodDecl) a.body(b);
              List l = new TypedList(new LinkedList(), ClassMember.class, false);
              l.add(mainMtdDecl);
	      l.addAll(parser.defineESJExtraMethods(mainMtdDecl));
              RESULT = l; 
	   
                                        :};

fn_method_header ::=
    ALLOY:z modifiers_or_annotations_opt:a type:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN:g dims_opt:e throws_opt:f {:
                                                                                                                                   RESULT = parser.nf.ESJMethodDecl(null, a, b, c.getIdentifier(), d, f, null, new TypedList(new LinkedList(), TypeNode.class, false), b.toString().equals("boolean"));
            
                                                                                                                                   :};

fn_method_body ::=
    fn_block:a {:   RESULT = a;   :};

fn_block ::=
    LBRACE:n fn_block_statements:a RBRACE:d {:
                                            RESULT = parser.nf.Block(parser.pos(n, d), a); 
                                            :};

fn_block_statements ::=
    fn_statement:a {:
                   List l = new TypedList(new LinkedList(), Stmt.class, false);
              l.add(a);
              RESULT = l; 
	   
                   :};

fn_statement ::=
    predicate_expr:a {:
                     RESULT = parser.nf.JL5Return(parser.pos(a), a); 
                     :};

comprehension_expression ::=
    LBRACE esj_type:g name:b quant_list_expr:d OR:e equality_predicate_expr:f RBRACE {:
                                                                                     if (d == null) 
	         d = parser.nf.ESJQuantifyTypeExpr(null,((AmbTypeNode)g).name());
	      RESULT = parser.makeESJQuantifyExpr(null,true,FormulaBinary.ALL,g,b.toString(),d,f);
	   
                                                                                     :};

quantify_expression ::=
    quant_kind:a esj_type:g name:b quant_list_expr:d OR:e equality_predicate_expr:f {:
                                                                                    if (a == FormulaBinary.NO) {
	          a = FormulaBinary.ALL;
		  f = parser.nf.Unary(null, Unary.NOT, f);
	       }
             if (d == null)
	         d = parser.nf.ESJQuantifyTypeExpr(null,((AmbTypeNode)g).name());
	     RESULT = parser.makeESJQuantifyExpr(null,false,a,g,b.toString(),d,f); 
	   
                                                                                    :};

quant_list_expr ::=
    COLON primary_no_new_array:a {:  RESULT = a;  :}
 |  {:   RESULT = null;   :};

esj_type ::=
    esj_primitive_type:a {:  RESULT = a;  :}
 |  esj_reference_type:a {:  RESULT = a;  :};

esj_primitive_type ::=
    esj_int_type:a {:  RESULT = a;  :};

esj_int_type ::=
    INT:a {:
           
	     RESULT = parser.nf.AmbTypeNode(null, "polyglot.ext.esj.primitives.ESJInteger");
	   
          :};

esj_reference_type ::=
    name:a {:
            
	     //RESULT = parser.nf.CanonicalTypeNode(null, parser.ts.typeForName(a.toString()));
	     RESULT = parser.nf.AmbTypeNode(null, a.toString());
	   
           :};

quant_kind ::=
    ALL {:  RESULT = FormulaBinary.ALL;  :}
 |  SOME {:  RESULT = FormulaBinary.SOME;  :}
 |  NO {:  RESULT = FormulaBinary.NO;  :}
 |  ONE {:  RESULT = FormulaBinary.ONE;  :}
 |  LONE {:  RESULT = FormulaBinary.LONE;  :};

predicate_expr ::=
    or_predicate_expr:a {:  RESULT = a;  :};

or_predicate_expr ::=
    and_predicate_expr:a orPredExpr_opt:b {:
                                          if (b == null)
		  RESULT = a;
	       else
		  RESULT = parser.nf.FormulaBinary(parser.pos(a), a,
		                            Binary.COND_OR, b); 
	    
                                          :};

orPredExpr_opt ::=
    {:  RESULT = null;  :}
 |  OROR or_predicate_expr:a {:  RESULT = a;  :};

and_predicate_expr ::=
    equality_predicate_expr:a andPredExpr_opt:b {:
                                                if (b == null)
		  RESULT = a;
	       else
		  RESULT = parser.nf.FormulaBinary(parser.pos(a), a,
				            Binary.COND_AND, b); 
	    
                                                :};

andPredExpr_opt ::=
    {:  RESULT = null;  :}
 |  ANDAND and_predicate_expr:a {:  RESULT = a;  :};

equality_predicate_expr ::=
    conditional_predicate_expr:a {:  RESULT = a;  :}
 |  quantify_expression:a {:  RESULT = a;  :}
 |  comprehension_expression:a {:  RESULT = a;  :}
 |  relational_predicate_expr:a {:  RESULT = a;  :}
 |  relational_predicate_expr:a equality_predicate_op:b equality_predicate_expr:c {:
                                                                                  RESULT = parser.nf.CmpBinary(parser.pos(a), a, b, c); 
                                                                                  :};

equality_predicate_op ::=
    EQEQ {:  RESULT = Binary.EQ;  :}
 |  NOTEQ {:  RESULT = Binary.NE;  :};

conditional_predicate_expr ::=
    relational_predicate_expr:a QUESTION equality_predicate_expr:b COLON equality_predicate_expr:c {:
                                                                                                  
	        RESULT = parser.nf.JL5Conditional(parser.pos(a, c), a, b, c); 
	     
                                                                                                   :};

relational_predicate_expr ::=
    additive_predicate_expr:a {:  RESULT = a;  :}
 |  additive_predicate_expr:a relational_predicate_op:b relational_predicate_expr:c {:
                                                                                    RESULT = parser.nf.CmpBinary(parser.pos(a), a, b, c); 
                                                                                    :};

relational_predicate_op ::=
    LT {:  RESULT = Binary.LT;  :}
 |  LTEQ {:  RESULT = Binary.LE;  :}
 |  GT {:  RESULT = Binary.GT;  :}
 |  GTEQ {:  RESULT = Binary.GE;  :};

additive_predicate_expr ::=
    multiplicative_predicate_expr:a {:  RESULT = a;  :}
 |  multiplicative_predicate_expr:a additive_predicate_op:b additive_predicate_expr:c {:
                                                                                      RESULT = parser.nf.Binary(parser.pos(a), a, b, c); 
                                                                                      :};

additive_predicate_op ::=
    PLUS {:  RESULT = Binary.ADD;  :}
 |  MINUS {:  RESULT = Binary.SUB;  :};

multiplicative_predicate_expr ::=
    unary_predicate_expr:a {:  RESULT = a;  :}
 |  unary_predicate_expr:a MULT multiplicative_predicate_expr:b {:
                                                                RESULT = parser.nf.Binary(parser.pos(a), a,
	                                Binary.MUL, b); 
                                                                :};

unary_predicate_expr ::=
    atomic_predicate_expr:a {:  RESULT = a;  :}
 |  MINUS unary_predicate_expr:a {:
                                 RESULT = parser.nf.Unary(parser.pos(a), Unary.NEG, a); 
                                 :}
 |  NOT unary_predicate_expr:a {:
                               RESULT = parser.nf.Unary(parser.pos(a), Unary.NOT, a); 
                               :};

atomic_predicate_expr ::=
    predicate_literal:a {:  RESULT = a;  :}
 |  formal_or_field_access:a {:  RESULT = a;  :}
 |  LPAREN predicate_expr:a RPAREN {:  RESULT = a;  :};

formal_or_field_access ::=
    simple_name:a {:  RESULT = a.toExpr();  :}
 |  THIS:a {:  RESULT = parser.nf.This(parser.pos(a));  :}
 |  IDENTIFIER:a LPAREN argument_list_opt:b RPAREN:c {:
                                                     RESULT = parser.classFieldNs.contains(a.getIdentifier()) ?
		   parser.nf.ESJFieldCall(parser.pos(a, c), null, a.getIdentifier(),b) :
		   parser.nf.Call(parser.pos(a, c), a.getIdentifier(),b);
	   
                                                     :}
 |  field_prefix:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                        RESULT = parser.classFieldNs.contains(b.getIdentifier()) ? 
		   parser.nf.ESJFieldCall(parser.pos(b,d), a, b.getIdentifier(),c) :
		   parser.nf.Call(parser.pos(b,d), a, b.getIdentifier(),c);
           
                                                                        :}
 |  field_prefix:a DOT IDENTIFIER:b {:
                                    RESULT = parser.nf.Field(parser.pos(b), a,
				       b.getIdentifier()); 
                                    :}
 |  field_prefix:a closure_kind:c fields_closure:ids {:
                                                     RESULT = parser.nf.ESJFieldClosure(null, a, c == FormulaBinary.MAP ? "dontcare" : (String) ids.get(0), c, ids, parser.currClassName); 
	   
                                                     :}
 |  field_prefix:a DOT:c fields_closure_multi:ids {:
                                                  RESULT = parser.nf.ESJFieldClosure(null, a, (String) ids.get(0), FormulaBinary.SIMP, ids, parser.currClassName); 
	   
                                                  :}
 |  formal_or_field_access:a LBRACK predicate_expr:b RBRACK:c {:
                                                              RESULT = parser.nf.ArrayAccess(parser.pos(a, c), a, b); 
                                                              :};

field_prefix ::=
   
 |  THIS:a {:  RESULT = parser.nf.This(parser.pos(a));  :}
 |  simple_name:a {:  RESULT = a.toReceiver();  :}
 |  field_prefix:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d {:
                                                                        RESULT = parser.classFieldNs.contains(b.getIdentifier()) ? 
	           parser.nf.ESJFieldCall(parser.pos(b,d), a, b.getIdentifier(),c) :
	           parser.nf.Call(parser.pos(b,d), a, b.getIdentifier(),c);
           
                                                                        :}
 |  field_prefix:a DOT IDENTIFIER:b {:
                                    RESULT = parser.nf.Field(parser.pos(b), a,
				       b.getIdentifier()); 
                                    :}
 |  field_prefix:a closure_kind:c fields_closure:ids {:
                                                     RESULT = parser.nf.ESJFieldClosure(null, a, c == FormulaBinary.MAP ? "dontcare" : (String) ids.get(0), c, ids, parser.currClassName);
	   
                                                     :}
 |  field_prefix:a DOT:c fields_closure_multi:ids {:
                                                  RESULT = parser.nf.ESJFieldClosure(null, a, (String) ids.get(0), FormulaBinary.SIMP, ids, parser.currClassName);
	   
                                                  :}
 |  formal_or_field_access:a LBRACK predicate_expr:b RBRACK:c {:
                                                              RESULT = parser.nf.ArrayAccess(parser.pos(a, c), a, b); 
                                                              :};

predicate_literal ::=
    INTEGER_LITERAL:a {:
                      RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue()); 
                      :}
 |  BOOLEAN_LITERAL:a {:
                      RESULT = parser.nf.BooleanLit(parser.pos(a),
                                         a.getValue().booleanValue()); 
                      :}
 |  NULL_LITERAL:a {:  RESULT = parser.nf.NullLit(parser.pos(a));  :};

ensured_method_declaration ::=
    ensured_method_header:a method_body:b {:
                                          ESJEnsuredMethodDecl mainMtdDecl = (ESJEnsuredMethodDecl) a.body(b);
              List l = new TypedList(new LinkedList(), ClassMember.class, false);
	      l.add(mainMtdDecl);
	    l.add(parser.makeFallbackMtd(mainMtdDecl, mainMtdDecl.modifiableFields(), mainMtdDecl.modifiableObjects()));
              RESULT = l; 
	   
                                          :};

ensured_method_header ::=
    modifiers_or_annotations_opt:a type:b method_declarator:c throws_opt:d modifies_fields_opt:y modifies_objects_opt:x ensures_clause:z {:
                                                                                                                                         
	    RESULT = parser.makeESJEnsuredMethodDecl(c.position(), a, b, c.name(), c.formals(), d, null, new TypedList(new LinkedList(), TypeNode.class, false), z, y, x); 
           
                                                                                                                                         :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c type:d method_declarator:e throws_opt:f modifies_fields_opt:y modifies_objects_opt:x ensures_clause:z {:
                                                                                                                                                                      
	       RESULT = parser.makeESJEnsuredMethodDecl(e.position(), a, d, e.name(), e.formals(), f, null, c, z, y, x); 
	   
                                                                                                                                                                      :}
 |  modifiers_or_annotations_opt:a VOID:b method_declarator:c throws_opt:e modifies_fields_opt:y modifies_objects_opt:x ensures_clause:z {:
                                                                                                                                         
	       RESULT = parser.makeESJEnsuredMethodDecl(c.position(), a, parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), c.name(), c.formals(), e, null, new TypedList(new LinkedList(), TypeNode.class, false), z, y, x); 
           
                                                                                                                                         :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c VOID:d method_declarator:e throws_opt:f modifies_fields_opt:y modifies_objects_opt:x ensures_clause:z {:
                                                                                                                                                                                                                                                                       RESULT = parser.makeESJEnsuredMethodDecl(e.position(), a, parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), e.name(), e.formals(), f, null, c, z, y, x); 
           
                                                                                                                                                                      :};

ensures_opt ::=
    {:  RESULT = null;   :}
 |  ensures_clause:a {:   RESULT = a;   :};

ensures_clause ::=
    ENSURES predicate_expr:a {:  RESULT = a;  :};

modifies_fields_opt ::=
    {: 
	      RESULT = null;
            :}
 |  modifiableFields:a {:   
	      RESULT = a;  
	    :};

modifiableFields ::=
    MODIFIESFIELDS modifiableFields_list:a {:
                                            
              RESULT = a;  
	   
                                           :};

modifiableFields_list ::=
    name:a {:
           List l = new TypedList(new LinkedList(), Name.class, false);
	      l.add(a);
	      RESULT = l; 
	   
           :}
 |  modifiableFields_list:a COMMA name:b {:
                                         RESULT = a;
	      a.add(b); 
	   
                                         :};

modifiableObjects ::=
    MODIFIESOBJECTS primary_no_new_array:a {:
                                            
              RESULT = a;  
	   
                                           :};

modifies_objects_opt ::=
    {: 
	      RESULT = null;
            :}
 |  modifiableObjects:a {:   
	      RESULT = a;  
	    :};

esj_enum_declaration ::=
    modifiers_or_annotations_opt:a ESJENUM:b IDENTIFIER:c interfaces_opt:d enum_body:e {:
                                                                                           parser.enums.add(c.getIdentifier());
	       RESULT = parser.nf.JL5ClassDecl(parser.pos(b, e), a.classicFlags(JL5Flags.setEnumModifier(a.classicFlags())), c.getIdentifier(), parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Enum()), d, e, new TypedList(new LinkedList(), TypeNode.class, false)); 
	    
                                                                                       :};

ensured_class_declaration ::=
    modifiers_or_annotations_opt:a CLASS:b IDENTIFIER:c {:
                                                        parser.currClassName(c.getIdentifier()); parser.resetGlobals(); 
                                                        :} type_parameters_opt:d super_opt:e interfaces_opt:f ensures_opt:z LBRACE class_body_declarations_opt:y RBRACE {:
                                                                                                                                                                        List extraMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
	      extraMtdBody.add(parser.nf.Return(null,z == null ? parser.nf.BooleanLit(null, true) : z));
	      ESJMethodDecl invariantMtdDecl = parser.nf.ESJMethodDecl(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), "verifyInvariants", new TypedList(new LinkedList(), Expr.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, extraMtdBody), new TypedList(new LinkedList(), TypeNode.class, false), true);
	      TypedList l = new TypedList(new LinkedList(), ClassMember.class, false);
	      
	      //if (e != null && parser.ts.typeForName(((AmbTypeNode)e).name()).isSubtype(parser.ts.typeForName("polyglot.ext.esj.primitives.ESJObject"))) //FIXME

	      if (!parser.currClassName.equals("MyList")) { // HACK FIXME
		  List gt = new TypedList(new LinkedList(), TypeNode.class, false);
		  AmbTypeNode cl = parser.nf.AmbTypeNode(null, c.getIdentifier());
		  gt.add(cl);
		  AmbTypeNode tn = parser.nf.AmbTypeNode(null, "polyglot.ext.esj.primitives.ESJList");
		  AmbTypeNode atn = parser.nf.JL5AmbTypeNode(null, ((AmbTypeNode)tn).qual(), ((AmbTypeNode)tn).name(), gt);
		  
	          //f.add(parser.nf.AmbTypeNode(null, "polyglot.ext.esj.primitives.ESJObject"));
		  f.add(parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.primitives.ESJObject")));

		  // add a default constructor used only for calling allInstances2 //
		  List basicL = new TypedList(new LinkedList(), Stmt.class, false);
		  basicL.add(parser.nf.SuperCall(null, parser.emptyArgs));
		  List ifBody = new TypedList(new LinkedList(), Stmt.class, false);
		  ifBody.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.This(null), "var_log"), Assign.ASSIGN, parser.nf.Local(null, "dontcare"))));
		  ifBody.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.This(null), "old"), Assign.ASSIGN, parser.nf.Call(null, parser.nf.This(null), "clone", parser.emptyArgs))));
		  ifBody.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.Field(null, parser.nf.This(null), "old"), "var_log"), Assign.ASSIGN, parser.nf.Local(null, "dontcare"))));
		  basicL.add(parser.nf.JL5If(null, parser.nf.Local(null, "isQuantifyVar"), parser.nf.Block(null, ifBody), null));
		  List<Flags> basicFs = new ArrayList<Flags>();
		  basicFs.add(Flags.PUBLIC);
		  List basicFrms = new TypedList(new LinkedList(), Formal.class, false);
		  basicFrms.add(parser.nf.JL5Formal(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogVar")), "dontcare"));
		  basicFrms.add(parser.nf.JL5Formal(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), "isQuantifyVar"));
		  l.add(parser.nf.JL5ConstructorDecl(null, parser.makeFlagAnnotations(basicFs), parser.currClassName, basicFrms, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, basicL), new TypedList(new LinkedList(), TypeNode.class, false)));
		  
		  List<Flags> fs3 = new ArrayList<Flags>();
		  fs3.add(Flags.PUBLIC);
		  FlagAnnotations fl = parser.makeFlagAnnotations(fs3);
		  // add a clone method
		  List cloneBody = new TypedList(new LinkedList(), Stmt.class, false);


		  List argsCB = new TypedList(new LinkedList(), Expr.class, false);
		  List args2CB = new TypedList(new LinkedList(), Expr.class, false);
		  args2CB.add(parser.nf.NullLit(null));
		  args2CB.add(parser.nf.NullLit(null));
		  argsCB.add(parser.nf.JL5New(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogVar")), args2CB, null, new TypedList(new LinkedList(), TypeNode.class, false)));
		  argsCB.add(parser.nf.BooleanLit(null, false));		   
		  cloneBody.add(parser.nf.JL5If(null, parser.nf.Call(null, null, "isCloned", parser.emptyArgs), parser.nf.JL5Return(null,parser.nf.This(null)), null));
		  cloneBody.add(parser.nf.JL5LocalDecl(null, parser.emptyFlags, parser.nf.AmbTypeNode(null, parser.currClassName), "res", parser.nf.JL5New(null, parser.nf.AmbTypeNode(null, parser.currClassName), argsCB, null, new TypedList(new LinkedList(), TypeNode.class, false))));
		  // add an old field and old_log, isOld mtds
		  l.add(parser.nf.JL5FieldDecl(null,parser.emptyFlags, parser.nf.AmbTypeNode(null, parser.currClassName) ,"old", null));
		  l.add(parser.nf.JL5MethodDecl(null, fl, parser.nf.AmbTypeNode(null, parser.currClassName), "old", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Field(null, parser.nf.This(null), "old"))), new TypedList(new LinkedList(), TypeNode.class, false))); 
		  //Expr isOldE1 = parser.nf.Binary(null, parser.nf.Field(null, parser.nf.This(null), "var_log"), Binary.EQ, parser.nf.NullLit(null));
		  Expr isOldE2 = parser.nf.Binary(null, parser.nf.Field(null, parser.nf.This(null), "old"), Binary.EQ, parser.nf.NullLit(null));
		  Expr isOldExpr = isOldE2; //parser.nf.Binary(null, isOldE1, Binary.COND_AND, isOldE2);

		  l.add(parser.nf.JL5MethodDecl(null, fl, parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), "isOld", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,isOldExpr)), new TypedList(new LinkedList(), TypeNode.class, false)));

		  // add a var_log field when obj is being used a quantify var
		  l.add(parser.nf.JL5FieldDecl(null,parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogVar")),"var_log", null));
		  l.add(parser.nf.JL5MethodDecl(null, fl, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogVar")), "var_log", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Field(null, parser.nf.This(null), "var_log"))), new TypedList(new LinkedList(), TypeNode.class, false))); 
		  l.add(parser.nf.JL5MethodDecl(null, fl, parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), "isQuantifyVar", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Binary(null, parser.nf.Field(null, parser.nf.This(null), "var_log"), Binary.NE, parser.nf.NullLit(null)))), new TypedList(new LinkedList(), TypeNode.class, false)));

		  // define a isRelationized mtd and isCloned mtd
		  l.add(parser.nf.JL5FieldDecl(null,parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Int()),"relationizerStep", parser.nf.IntLit(null, IntLit.INT, 0)));
		  l.add(parser.nf.JL5MethodDecl(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), "isRelationized", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null, parser.nf.Binary(null, parser.nf.Field(null, parser.nf.This(null), "relationizerStep"), Binary.EQ, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "relationizerStep", parser.emptyArgs)))), new TypedList(new LinkedList(), TypeNode.class, false)));

		  l.add(parser.nf.JL5FieldDecl(null,parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Int()),"clonerStep", parser.nf.IntLit(null, IntLit.INT, 0)));
		  l.add(parser.nf.JL5MethodDecl(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), "isCloned", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null, parser.nf.Binary(null, parser.nf.Field(null, parser.nf.This(null), "clonerStep"), Binary.EQ, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "clonerStep", parser.emptyArgs)))), new TypedList(new LinkedList(), TypeNode.class, false)));

 	      	 // define a static list to keep instance list
     	      	 List<Flags> fs = new ArrayList<Flags>();
	      	 fs.add(Flags.STATIC);
		 l.add(parser.nf.JL5FieldDecl(null,parser.makeFlagAnnotations(fs), atn,"allInstances", parser.nf.JL5New(null, atn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
		 List<Flags> fs2 = new ArrayList<Flags>();
		 fs2.add(Flags.STATIC);
		 fs2.add(Flags.PUBLIC);
		 l.add(parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(fs2), atn, "allInstances", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Field(null, cl, "allInstances"))), new TypedList(new LinkedList(), TypeNode.class, false)));
		 List<Flags> fs1 = new ArrayList<Flags>();
		 fs1.add(Flags.PUBLIC);
		 l.add(parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(fs1), atn, "allInstances2", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Field(null, cl, "allInstances"))), new TypedList(new LinkedList(), TypeNode.class, false)));
		 List args2 = new TypedList(new LinkedList(), Expr.class, false);	   
		 args2.add(parser.nf.ClassLit(null, cl));
		 args2.add(parser.nf.BooleanLit(null, false));
		 args2.add(parser.nf.BooleanLit(null, false));
		 l.add(parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(fs2),  parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogSet")), "allInstances_log", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "bounds_log", args2))), new TypedList(new LinkedList(), TypeNode.class, false)));
		 
		 // define LogObject general log methods (cmpOp, arithOp, etc.)
		 TypeNode logFormulaTN = parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogFormula"));
		 List frms = new TypedList(new LinkedList(), Formal.class, false);
		 frms.add(parser.nf.JL5Formal(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.String()), "o"));
		 frms.add(parser.nf.JL5Formal(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.primitives.ESJObject")), "o2"));
		 List lfArgs = new TypedList(new LinkedList(), Expr.class, false);
		 lfArgs.add(parser.nf.Call(null, parser.nf.Field(null, parser.nf.This(null), "var_log"), "string", parser.emptyArgs));
		 lfArgs.add(parser.nf.Local(null,"o"));	     
		 lfArgs.add(parser.nf.Call(null, parser.nf.Call(null, parser.nf.Local(null,"o2"), "var_log", parser.emptyArgs), "string", parser.emptyArgs));
		 l.add(parser.nf.JL5MethodDecl(null, parser.emptyFlags, logFormulaTN, "cmpOp", frms, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, parser.nf.JL5Return(null, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogFormula")), "binaryOp", lfArgs))), new TypedList(new LinkedList(), TypeNode.class, false)));
		 frms.set(1,parser.nf.JL5Formal(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogObject")), "o2"));
		 lfArgs.set(2,parser.nf.Call(null, parser.nf.Local(null,"o2"), "string", parser.emptyArgs));
		 l.add(parser.nf.JL5MethodDecl(null, parser.emptyFlags, logFormulaTN, "cmpOp", frms, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, parser.nf.JL5Return(null, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogFormula")), "binaryOp", lfArgs))), new TypedList(new LinkedList(), TypeNode.class, false)));
		 				 
	      	 // define relationize() and relationizeOld() and clone()...
	      	 List args = new TypedList(new LinkedList(), Expr.class, false);
	      	 args.add(parser.nf.This(null));
	      	 List relationizeMtdSubBody = new TypedList(new LinkedList(), Stmt.class, false);
		 relationizeMtdSubBody.add(parser.nf.Eval(null, parser.nf.Unary(null, Unary.POST_INC, parser.nf.Field(null, parser.nf.This(null), "relationizerStep"))));
		 //relationizeMtdSubBody.add(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "newAtom", args)));
		 cloneBody.add(parser.nf.Eval(null, parser.nf.Unary(null, Unary.POST_INC, parser.nf.Field(null, parser.nf.This(null), "clonerStep"))));
	      	 List relationizeOldMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
		 //relationizeOldMtdBody.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.This(null), "old"), Assign.ASSIGN, parser.nf.Call(null, null, "clone", parser.emptyArgs))));
		 parser.BuildRelationizeOldAndCloneBody(y, relationizeOldMtdBody, relationizeMtdSubBody, cloneBody);

		 relationizeMtdSubBody.add(parser.nf.Eval(null, parser.nf.Call(null, null, "relationizeOld", new TypedList(new LinkedList(), Expr.class, false))));
		 List relationizeMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
		 relationizeMtdBody.add(parser.nf.JL5If(null, parser.nf.Unary(null, Unary.NOT, parser.nf.Call(null, null, "isRelationized", parser.emptyArgs)), parser.nf.Block(null, relationizeMtdSubBody), null));
		 JL5MethodDecl relationizeMtdDecl = parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(basicFs), parser.nf.CanonicalTypeNode(null, parser.ts.Void()), "relationize", new TypedList(new LinkedList(), Expr.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, relationizeMtdBody), new TypedList(new LinkedList(), TypeNode.class, false));
	      	 JL5MethodDecl relationizeOldMtdDecl = parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(basicFs), parser.nf.CanonicalTypeNode(null, parser.ts.Void()), "relationizeOld", new TypedList(new LinkedList(), Expr.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, relationizeOldMtdBody), new TypedList(new LinkedList(), TypeNode.class, false));
		 
		 cloneBody.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.This(null), "old"), Assign.ASSIGN, parser.nf.Local(null, "res"))));
		 cloneBody.add(parser.nf.JL5Return(null, parser.nf.Local(null, "res")));
		 
		 JL5MethodDecl cloneMtdDecl = parser.nf.JL5MethodDecl(null, fl, parser.nf.AmbTypeNode(null, parser.currClassName), "clone", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, cloneBody), new TypedList(new LinkedList(), TypeNode.class, false));
		 		 

	      	 l.add(relationizeMtdDecl);
	     	 l.add(relationizeOldMtdDecl);
	     	 l.add(cloneMtdDecl);
	      }
	      l.add(invariantMtdDecl);

	      // define an initEnsuredMethod mtd
	      List initEM = new TypedList(new LinkedList(), Stmt.class, false);
	      initEM.add(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "initRelationize", new TypedList(new LinkedList(), Expr.class, false))));
	      //if (!parser.currClassName.equals("MyList")) // HACK FIXME
		  //initEM.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.This(null), "old"), Assign.ASSIGN, parser.nf.Call(null, null, "clone", parser.emptyArgs))));
	      initEM.add(parser.nf.Eval(null, parser.nf.Call(null, null, "clone", parser.emptyArgs)));
	      //initEM.add(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "ObjToAtomMap", new TypedList(new LinkedList(), Expr.class, false))));
	      //initEM.add(parser.nf.Eval(null, parser.nf.Call(null, null, "relationize", new TypedList(new LinkedList(), Expr.class, false))));
	      l.add(parser.nf.JL5MethodDecl(null, parser.emptyFlags, parser.nf.CanonicalTypeNode(null, parser.ts.Void()), "initEnsuredMethod", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, initEM), new TypedList(new LinkedList(), TypeNode.class, false)));

	      l.addAll(parser.defineESJExtraMethods(invariantMtdDecl));	
	      l.addAll(y);

	      RESULT = parser.nf.ESJEnsuredClassDecl(null, a, c.getIdentifier(), e, f, parser.nf.JL5ClassBody(null, l), d); 
           
                                                                                                                                                                        :};

esj_field_declaration ::=
    SPEC:z modifiers_or_annotations_opt:a type:b variable_declarators:c SEMICOLON:e {:
                                                                                    List l = new TypedList(new LinkedList(), ClassMember.class, false);
	    // HACK FIXMES:
	    List tpAs = ((JL5AmbTypeNode) b).typeArguments();
	    boolean isCollectionType = tpAs.size() > 0;
	    boolean isListType = ((AmbTypeNode) b).name().equals("ESJList");
	    TypeNode fTN = isCollectionType ? (TypeNode) tpAs.get(0) : parser.nf.AmbTypeNode(null, ((AmbTypeNode) b).name());
	    boolean isEnumFd = b instanceof JL5AmbTypeNode && parser.enums.contains(((AmbTypeNode) b).name());
 	      // HACK FIXME:
	    JL5ParsedClassType tt = null;
	      try {
		  tt = (JL5ParsedClassType) parser.ts.typeForName(((AmbTypeNode) b).name());
		  if (JL5Flags.isEnumModifier(tt.flags())) {
		      isEnumFd = true;		      
		  }
	      } catch (Exception e2) 
		  {  }
	   
       	      for (Iterator i = c.iterator(); i.hasNext(); ) {
              	  VarDeclarator d = (VarDeclarator) i.next();
		  if (a.classicFlags().isStatic() || a.classicFlags().isFinal()) {
		      l.add(parser.nf.JL5FieldDecl(parser.pos(b, e),a, b, d.name, d.init));
		  } else {
		      l.add(parser.nf.ESJFieldDecl(parser.pos(b, e),a, b, d.name, d.init, false));
		      boolean isReferenceType = b instanceof JL5AmbTypeNode && !b.toString().equals("Integer{amb}"); //FIXME
		      //System.out.println("somebody adding a fieeeeeld!" + d.name + " " + isReferenceType);
		      List args = new TypedList(new LinkedList(), Expr.class, false);
		      List relDefBodyArgs = new TypedList(new LinkedList(), Expr.class, false);
		      
		      relDefBodyArgs.add(parser.nf.ClassLit(null, parser.nf.AmbTypeNode(null, parser.currClassName)));
		      relDefBodyArgs.add(parser.nf.StringLit(null,d.name));
		      relDefBodyArgs.add(parser.nf.ClassLit(null, parser.nf.AmbTypeNode(null, parser.currClassName)));
		      relDefBodyArgs.add(parser.nf.ClassLit(null, fTN));
		      relDefBodyArgs.add(parser.nf.BooleanLit(null, isCollectionType));
		      relDefBodyArgs.add(parser.nf.BooleanLit(null, isListType));
		      relDefBodyArgs.add(parser.nf.BooleanLit(null, true));
		      Block relDefBody = parser.nf.Block(null, parser.nf.Eval(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "newInstVarRel", relDefBodyArgs)));
		      l.add(parser.nf.Initializer(null, Flags.STATIC, relDefBody));
		      args.add(parser.nf.StringLit(null, d.name));
		      
		      // add an _log ver of field also
		      
		      TypeNode b2 = isReferenceType ? fTN : parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.primitives.ESJInteger")); //FIXME
		      //l.add(parser.nf.ESJFieldDecl(parser.pos(b, e),a, b2, d.name+"_log", null, true));
		      //l.add(parser.nf.ESJFieldDecl(parser.pos(b, e),a, b2, d.name+"_old_log", null, true));
		      
		      List instVarGetArgs = new TypedList(new LinkedList(), Expr.class, false);
		      List instVarGetBody = new TypedList(new LinkedList(), Stmt.class, false);
		      List args3p = new TypedList(new LinkedList(), Expr.class, false);
		      args3p.add(parser.nf.This(null));
		      //args3p.add(parser.nf.StringLit(null, d.name));
		      args3p.add(parser.nf.JL5Conditional(null, parser.nf.Call(null, null, "isOld", parser.emptyArgs), parser.nf.StringLit(null, d.name+"_old"), parser.nf.StringLit(null, d.name))); 
		      TypeNode ivgRT;
		      Expr nExpr = null;
		      Expr rExp = null;
		      // HACK FIXME
		      if (isCollectionType) {
			  ivgRT = parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogSet"));
			  b2 = ivgRT;
			  rExp = parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "objInstVarSet_log", args3p);
		      } else {
			  List args2p = new TypedList(new LinkedList(), Expr.class, false);
			  Expr ivgExpr = parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "objInstVarStr_log", args3p);
			  args2p.add(ivgExpr);
			  if (!isEnumFd)
			  args2p.add(parser.nf.ClassLit(null, b2));
			  TypeNode tn1 = parser.nf.CanonicalTypeNode(null, parser.ts.typeForName(isEnumFd ? "polyglot.ext.esj.tologic.LogObjAtom" : "polyglot.ext.esj.tologic.LogVar"));
			  nExpr = parser.nf.JL5New(null, tn1, args2p, null, new TypedList(new LinkedList(), TypeNode.class, false));
			  instVarGetArgs.add(nExpr);
			  instVarGetArgs.add(parser.nf.BooleanLit(null, true));
			  List args4 = new TypedList(new LinkedList(), Expr.class, false);
			  args4.add(parser.nf.Field(null, parser.nf.This(null), "var_log"));
			  //instVarGetBody.add(parser.nf.Eval(null,parser.nf.Call(null, parser.nf.Field(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("java.lang.System")),"out"), "println", args4)));
			  
			  ivgRT = isEnumFd ? parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogObjAtom")) : b2;
			  rExp = isEnumFd ? nExpr : parser.nf.JL5New(null, b2, instVarGetArgs, null, new TypedList(new LinkedList(), TypeNode.class, false));			  
		      }
		      instVarGetBody.add(parser.nf.JL5Return(null, rExp));
		      l.add(parser.nf.JL5MethodDecl(null, a, ivgRT, d.name+"_log", parser.emptyFormals, new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, instVarGetBody), new TypedList(new LinkedList(), TypeNode.class, false)));		     
		      
		      //TypedList relDefBodyArgsP = TypedList.copy(relDefBodyArgs, Expr.class, false);
		      relDefBodyArgs.set(6,parser.nf.BooleanLit(null, false));
		      Block relDefBodyP = parser.nf.Block(null, parser.nf.Eval(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "newInstVarRel", relDefBodyArgs)));
		      l.add(parser.nf.Initializer(null, Flags.STATIC, relDefBodyP));
		      
		      List gt = new TypedList(new LinkedList(), TypeNode.class, false);
		      AmbTypeNode cl = parser.nf.AmbTypeNode(null, parser.currClassName);
		      gt.add(cl);
		      AmbTypeNode tn = parser.nf.AmbTypeNode(null, "java.util.ArrayList");
		      AmbTypeNode atn = parser.nf.JL5AmbTypeNode(null, ((AmbTypeNode)tn).qual(), ((AmbTypeNode)tn).name(), gt);
		      
		      AmbTypeNode settn = parser.nf.AmbTypeNode(null, "polyglot.ext.esj.primitives.ESJSet");
		      AmbTypeNode asettn = parser.nf.JL5AmbTypeNode(null, ((AmbTypeNode)settn).qual(), ((AmbTypeNode)settn).name(), gt);
		      
		      TypeNode fT = b.toString().equals("int") ? parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("java.lang.Integer")) : b; //FIXME
		      
		      List gt2 = new TypedList(new LinkedList(), TypeNode.class, false);
		      gt2.add(fT);
		      AmbTypeNode asettn2 = parser.nf.JL5AmbTypeNode(null, ((AmbTypeNode)settn).qual(), ((AmbTypeNode)settn).name(), gt2);
		      
		      
		      // define setMap_<field> mtd
		      l.add(parser.makeSetMapFieldMethod(d.name, fT, cl, tn, asettn, asettn2));
		      // also define field closure access for recursive fields
		      if (b.toString().equals(parser.currClassName+"{amb}") && parser.noClosureDefYet) { //FIXME
			  parser.noClosureDefYet(false);
			  l.add(parser.makeFieldClosureMethod(cl, tn, asettn));
			  l.add(parser.makeMultiFieldsMethod(cl, tn, asettn));
		      }
		  }
              }
	    
	    RESULT = l; 
           
                                                                                    :};

closure_kind ::=
    DOT MULT {:  RESULT = FormulaBinary.RFLX;  :}
 |  DOT XOR {:  RESULT = FormulaBinary.NONRFLX;  :}
 |  DOT LT {:  RESULT = FormulaBinary.MAP;  :};

fields_closure ::=
    IDENTIFIER:a {:
                 List ids = new TypedList(new LinkedList(), String.class, false);
	      ids.add(a.getIdentifier());
	      RESULT = ids;
	   
                 :}
 |  fields_closure_multi:a {:  RESULT = a;
	    :};

fields_closure_multi ::=
    LPAREN identifiers_union:ids RPAREN {:  RESULT = ids;
	    :};

identifiers_union ::=
    IDENTIFIER:a {:
                 List ids = new TypedList(new LinkedList(), String.class, false);
	      ids.add(a.getIdentifier());
	      RESULT = ids;
	   
                 :}
 |  identifiers_union:ids PLUS IDENTIFIER:a {:
                                            ids.add(a.getIdentifier());
	      RESULT = ids;
	   
                                            :};


